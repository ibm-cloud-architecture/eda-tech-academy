{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Event-driven solution - Tech Academy Workshop","text":"<p>The general objective of this academy training is to develop deeper technical skills, within the IBM technical community, to plan, design, build and execute a sub-set of key Proof Of Concept tasks and activities.</p> <p>In this Event-driven solution workshop, you will learn how to use of Event-Driven/Near Real-time Integration Patterns, Technologies and Implementation Strategies which should help you developing simple Streaming  applications and proof of concepts.\u00a0</p>"},{"location":"#two-possible-journeys","title":"Two possible journeys","text":"<p>We recognize that not every student will have the same level of knowledge of Event Streams and integration capability or even Java development background. We propose two different tracks depending of your current skill level:</p> <ol> <li> <p>Beginner journey: do the demonstration lab, which is about being confortable to demonstrate Event Streams from \"A to Z\": this is a good 3 hours run thru exercise that will give you access to a lot of content you should be able to leverage overtime. You may also do the lab 1 as this is a system design mockup exercise, that should help you in the future. Go to Track 1 - demonstration lab &gt;&gt;</p> </li> <li> <p>Advance journey: Perform labs 1 to 4, this is about learning Kafka Stream, Open Liberty application, using Configuration as Code for OpenShift deployment and GitOps approach. A full story and a set of reusable assets you may want to reuse to build you future proof of concepts. You can also review quickly the demonstration lab, as it could be helpful, as a script to answer specific customer's questions.  Continue to the goals section below &gt;&gt;</p> </li> </ol>"},{"location":"#advance-journey-goals","title":"Advance Journey Goals:","text":"<ul> <li>Solidify a full body of knowledge in the near real-time / event driven architecture domain\u00a0</li> <li>Design and create an initial prototype solution that addresses the DOU goals and objectives.</li> <li>Establish an initial point of view for adopting GitOps methods and practices for event streams implementations.</li> <li>Give you foundational knowledge to deeply address event-driven solution design </li> </ul>"},{"location":"#study-optional-lecture-review-key-eda-patterns-use-cases-and-usage-scenarios","title":"Study [Optional] - Lecture: Review key EDA patterns, use cases and usage scenarios.","text":"<ul> <li>Duration: 20 minutes.</li> <li>Delivery: presenter will go over some concepts and presentation of the material. Can be self space study.</li> </ul> <p>What are the technical use cases where Event Streams is a good fit. Why customers are going full speed to adopt EDA?</p> <ul> <li>Technical use cases - general positioning</li> <li>Assessment questions for Event Streams opportunity</li> <li>Detailed use case slides</li> </ul> Read more <ul> <li>EDA internal site - use cases</li> <li>EDA public web site we use to present content to customers</li> </ul>"},{"location":"#lab-1-system-design-for-a-real-time-inventory-solution","title":"Lab 1: System design for a real-time inventory solution","text":"<ul> <li>Duration: 30 minutes</li> <li>Delivery: Can be done with 2 or 3 students and self pace.</li> </ul> <p>Review the Client provided requirements, and elaborate a system design for an EDA solution.</p> <ul> <li>Review the problem statement and the lab's instructions</li> <li>A potential solution may look like</li> </ul>"},{"location":"#lab-2-optional-implement-a-simple-item-sell-or-restock-event-stream-processing-with-kafka-streams-api","title":"Lab 2 [Optional]: Implement a simple item sell or restock event stream processing with Kafka Streams API","text":"<p>Learning the basic of Kafka Streams, and implement a store aggregation processing with Java. The code and environment should be self efficient. </p> <ul> <li>Optional: if you really hate programming you can skip this lab, or at least read the first few exercices so you can understand some of the streaming concepts.</li> <li>Duration: 90 minutes</li> <li> <p>Delivery: Pair programming.</p> </li> <li> <p>Lab's instructions includes a set of progressing exercise to learn basic Kafka Streams programming.</p> </li> <li>Last exercise solution.  </li> </ul>"},{"location":"#lab-3-deploy-the-real-time-inventory-solution-in-one-click","title":"Lab 3: Deploy the real time inventory solution in one Click","text":"<p>Duration: 20 minutes</p> <p>This is a simple of the end to end solution, you will be able to deploy in few commands. It is also important to review some deployment definition content:</p> <p>20 minutes lab</p>"},{"location":"#lab-4-deploy-the-solution-with-openshift-gitops","title":"Lab 4: Deploy the solution with OpenShift GitOps","text":"<p>Duration: 30 minutes</p> <p>In this lab, you will deploy the ArgoCD applications that monitor your git repository for any change to the configuration and deploy the different services and MQ broker in your own namespace.</p> <p>Lab 4 GitOps deployment</p>"},{"location":"#lab-5-optional-monitor-with-instana","title":"Lab 5 [Optional]: Monitor with Instana","text":""},{"location":"eda/","title":"Why event-driven architecture","text":"<p>adoption for loosely coupled, event-driven microservice solutions, with new data pipeline used to inject data to modern data lakes, and the adoption of event backbone technology like Apache Kafka, or Apache Pulsar.</p> <p>Event-driven architecture (EDA) is an architecture pattern that promotes the production, detection, consumption of, and reaction to events. It supports asynchronous communication between components and most of the time a pub/sub programming model. The adoption of microservices brings some interesting challenges like data consistency, contract coupling, and scalability that EDA helps to address.</p> <p>From the business value point of view, adopting this architecture helps to scale business applications according to workload and supports easy extension by adding new components over time that are ready to produce or consume events that are already present in the overall system. New real-time data streaming applications can be developed which we were not able to do before.</p>"},{"location":"eda/#technical-needs","title":"Technical needs","text":"<p>At the technical level we can see three adoptions of event-driven solutions:</p> <ul> <li> <p>Modern data pipeline to move the classical batch processing of extract, transform and load job to real-time ingestion, where data are continuously visible in a central messaging backbone. The data sources can be databases, queues, or specific producer applications, while the consumers can be applications, streaming flow, long storage bucket, queues, databases\u2026</p> </li> <li> <p>Adopt asynchronous communication, publish-subscribe protocol between cloud-native microservices to help scaling and decoupling: the adoption of microservices for developing business applications, has helped to address maintenance and scalability, but pure RESTful or SOAP based solutions have brought integration and coupling challenges that inhibited the agility promised by microservice architecture. Pub/sub helps to improve decoupling, but design good practices are very important. See more about EDA advantages for microservices</p> </li> <li> <p>Real time analytics: this embraces pure analytic computations like aggregate on the data streams but also complex event processing, time window-based reasoning, or AI scoring integration on the data streams.</p> </li> </ul> Read more <ul> <li>business requirements</li> </ul>"},{"location":"future/","title":"Next steps","text":"<p>You can run on your own OpenShift cluster with existing assets and more assets available on the public Git repositories.</p>"},{"location":"future/#eda-community-call","title":"EDA Community Call","text":"<p>IBM - Internal: Register in Your Learning for a community call every Wednesday at 7:00am PST (Webex boyerje). We will organize the calls in different scope:</p> <ul> <li>Week 1 of every month: Beginner sessions for Kafka</li> <li>Week 2 of every month: Bring you own opportunity so we can share trick on how to make it progresses</li> <li>Week 3 of every month: Deeper dive: asset presentation, architecture, coding discussions</li> <li>Week 4 of event month: Project success story, opportunity success story, product roadmap update.</li> </ul>"},{"location":"future/#internal-site","title":"Internal site","text":"<p>IBM internal site for sharing knowledge on use cases / workshops / ...</p>"},{"location":"future/#kafka-connector-world","title":"Kafka Connector World","text":"<p>The Event Streams demonstration introduced the Kafka Connect framework, </p> <p></p> <p>The real time inventory solution uses MQ source connector, with the Kafka connector cluster defined in this kafka-connect.yaml file as:</p> <pre><code>apiVersion: eventstreams.ibm.com/v1beta2\nkind: KafkaConnect\nmetadata:\nname: std-1-connect-cluster\nannotations:\neventstreams.ibm.com/use-connector-resources: \"true\"\nspec:\nversion: 3.0.0\nreplicas: 2\nbootstrapServers: es-demo-kafka-bootstrap.cp4i-eventstreams.svc:9093\nimage: quay.io/ibmcase/eda-kconnect-cluster-image:latest\nresources:\nlimits:\ncpu: 2000m\nmemory: 2Gi\nrequests:\ncpu: 1000m\nmemory: 2Gi\ntemplate:\npod:\nimagePullSecrets: []\nmetadata:\nannotations:\nproductChargedContainers: std-1-connect-cluster-connect\neventstreams.production.type: CloudPakForIntegrationNonProduction\nproductID: 2a79e49111f44ec3acd89608e56138f5\nproductName: IBM Event Streams for Non Production\nproductVersion: 11.0.0\nproductMetric: VIRTUAL_PROCESSOR_CORE\ncloudpakId: c8b82d189e7545f0892db9ef2731b90d\ncloudpakName: IBM Cloud Pak for Integration\ncloudpakVersion: 2022.1.1\nproductCloudpakRatio: \"2:1\"\nconfig:\ngroup.id: std-1-connect-cluster\noffset.storage.topic: std-1-connect-cluster-offsets\nconfig.storage.topic: std-1-connect-cluster-configs\nstatus.storage.topic: std-1-connect-cluster-status\nconfig.storage.replication.factor: 3\noffset.storage.replication.factor: 3\nstatus.storage.replication.factor: 3\ntls:\ntrustedCertificates:\n- secretName: es-demo-cluster-ca-cert\ncertificate: ca.crt\nauthentication:\ntype: tls\ncertificateAndKey:\ncertificate: user.crt\nkey: user.key\nsecretName: std-1-tls-user\n</code></pre> <p>And the source definition kafka-mq-src-connector.yaml</p> <p>you may need to go deeper with labs and best practices: </p> <ul> <li>a technical summary</li> <li>MQ connector lab</li> <li>Deploy cloud object storage sink connector lab</li> <li>Deploy a S3 sink connector using Apache Camel</li> <li>Mirror maker 2.0 as a Kafka Framework solution</li> <li>Code source of the MQ source connector</li> <li>Code source of the Rabbit MQ connector and the matching lab</li> <li>Code source of the JDBC sink connector</li> </ul>"},{"location":"future/#reactive-messaging-programming","title":"Reactive Messaging Programming","text":"<p>Event-driven microservices adopt the reactive manifesto, which means use messaging as a way to communicate between components. When the components are distributed, Kafka or MQ are used as broker.</p> <p>Microprofile Reactive Messaging is a very elegant and easier way to integrate with Kafka / Event Streams. The best support for it, is in Quarkus and this reactive with kafka guide is a first read. The Microprofile Reactive Messaging 1.0 is supported in OpenLiberty with Microprofile 3.0.</p> <p>The code template in the EDA quickstart repository includes reactive messaging code template.</p>"},{"location":"future/#the-saga-implementation","title":"The SAGA implementation","text":"<p>Long running process between microservice is addressed by the adoption of the SAGA pattern. You can read about the pattern in this note</p> <p>And visit the Choreography implementation done with, Event Streams, Reactive Programming here</p> <ul> <li>Order microservice keeping SAGA coherence - git repository</li> <li>Reefer microservice participant to the SAGA - git repo</li> <li>Voyage microservice SAGA participant - git repo</li> </ul> <p>The orchestration implementation with, Event Streams, Reactive Programming here</p>"},{"location":"future/#change-data-capture-with-debezium-and-outbox-pattern","title":"Change data capture with Debezium and Outbox pattern","text":"<p>Very interesting lab with Debezium using outbox pattern.</p>"},{"location":"future/#full-gitops-story","title":"Full GitOps story","text":"<p>To get a better understanding of the EDA gitops process see this technical note and reuse the following git repostiories:</p> <ul> <li>EDA GitOps Catalog</li> <li>RT inventory gitops</li> </ul>"},{"location":"future/#instana-monitoring","title":"Instana monitoring","text":"<p>Deploying Instana APM on the Event Streams Cluster running on Openshift/kubernetes.</p> <ul> <li>Create the instana-agent project and set the policy permissions to ensure the instana-agent service account is in the privileged security context.</li> </ul> <pre><code>oc login -u system:admin\noc new-project instana-agent\noc adm policy add-scc-to-user privileged -z instana-agent\n</code></pre> <ul> <li>Login to Instana console: https://training-kafka.instana.io</li> <li>Click on Deploy agent on the Top right corner</li> </ul> <p></p> <p>Select OpenShift and enter the desired ClusterName/ClusterID that needs to be monitored with Instana. You find the clusterID from Openshift console.</p> <p>Download the yaml file generated by Instana</p> <p></p> <p>Navigate to<code>Openshift -&gt; Workloads -&gt; DeamonSets</code> and import the instana-agent.yaml and create the deamonset per each of the document streams inside the yaml separately. </p> <p>For example, since we already created the name space and serviceaccount in Step1, we can skip the first two documents below and start from Kind:secret.</p> <p></p> <p>Once DeamonSet has been successfully created, validate that the pods are running suceessfully, wait for 5 minutes for instana to automatically discover the kafka components and instrument them.</p> <p></p>"},{"location":"demo/","title":"Demonstrating Event Streams from A to Z","text":"<p>Warning</p> <p>This exercise is not a step by step lab, but more an explanation of all the concepts and components involved in an event-driven solution with Event Streams. We have provided scripts that can be leveraged (see the table of content on the right to get scripts) to demonstrate and talk about those items in front of your prospect. </p> <p>A typical demonstration script will include at least the following subjects (See right navigation bar to go to a specific sections):</p> <ul> <li>Review Event Streams Components</li> <li>Operator based deployment and Day 2 operations</li> <li>Topic creation</li> <li>Producer application</li> <li>Consumer application, consumer group concepts, offset concepts</li> <li>User access, authentication mechanism</li> <li>Monitoring</li> <li>Event Streaming</li> <li>Geo-replication</li> </ul> <p>As education enablement you can go step by step following the current structure. As a reusable asset for your future demonstration, you can pick and choose from the right navigation bar the items to highlight in front of your audiance.</p> <p>All the demonstration can be done on IBM CoC clusters: see the environments section in the EDA labs introduction.</p>"},{"location":"demo/#pre-requisites","title":"Pre-requisites","text":"<p>You will need access to an Event Streams instance installed on an OpenShift cluster with access to the OpenShift Console to demonstrate Operators. </p> <p>You\u2019ll need the following as well:</p> <ul> <li>git client</li> <li> <p>Have oc cli installed. It can be done once connected to the OpenShift cluster using the &lt;?&gt; icon on the top-right and \"Command Line Tool\" menu.</p> <p></p> </li> <li> <p>Get docker desktop or podman on your local laptop</p> </li> <li>Java 11 is need to run the Event Streams starter application.</li> </ul>"},{"location":"demo/#review-event-streams-components","title":"Review Event Streams components","text":"<p>Narative: Event Streams is the IBM packaging of different Open Source projects to support an integrated user experience deploying and managing Kafka on OpenShift cluster. The following figure illustrates such components:</p> <p></p> <p>src for this diagram is here</p> <ul> <li>Event streams (Apache Kafka packaging) runs on OpenShift cluster.</li> <li>The deployment and the continuous monitoring of Event Streams resources definition and deployed resources is done via Operator (Strimzi open source project)</li> <li>Event Streams offers a user interface to manage resources and exposes simple dashboard. We will use it during the demonstration.</li> <li>The schema management is done via schema registry and the feature is integrated in Event Streams user interface but in the back end, is supported by Apicur.io registry</li> <li>External event sources can be integrated via the Kafka Connector framework and Event Streams offers a set of connectors and can partner to other companies to get specific connectors.</li> <li>External sinks can be used to persist messages for longer time period that the retention settings done at the topic level. S3 buckets can be use, IBM Cloud object storage, and Kafka Sink connectors. There is this cloud object storage lab, or S3 sink with Apache Camel lab to present such integrations.</li> <li>Event Streams monitoring is done using Dashboards in Event Streams user interface but also within OpenShift monitoring and Kibana dashboards.</li> <li>Green components are application specifics, and represent event-driven microservices (see eda-quickstart project for code templates) or Kafka Streaming apps, or Apache Flink apps.</li> <li>For cluster optimization, Event Streams integrates Cruise Control, with goal constraints, to act on cluster resource usage.</li> </ul> More argumentations <ul> <li>Kafka is essentially a distributed platform to manage append log with a pub/sub protocol to get streams of events. Messages are saved for a long period of time.</li> <li>Kafka connectors can also being supported by APP Connect integration capabilities or Apache Camel kafka connectors.</li> <li>To learn more about Kafka Connector see our summary</li> </ul>"},{"location":"demo/#concepts","title":"Concepts","text":"<p>If needed there are some important concepts around Kafka to present to your audience. See this kafka technology overview.</p>"},{"location":"demo/#high-availability","title":"High Availability","text":"<p>High availability is ensured by avoiding single point of failure, parallel, and replications. The following figure is a golden topology for OpenShift with Event Streams components deployed to it. Event Streams Brokers run in OpenShift worker nodes, and it may be relevant to use one broker per worker nodes using zone affinity policies. </p> <p> src for this diagram is here</p> <p>Kafka connectors, or streaming applications runs in worker node too and access brokers via mutual TLS authentication and SSL encryption.</p> <p>Kafka brokers are spread across worker nodes using anti-affinity policies.</p> Read more <ul> <li>Kafka High availability deeper dive</li> <li>See the OpenShift golden topology article in production deployment site.</li> <li>A production deployment descriptor for Event Streams</li> <li>Product documentation on planning installation</li> </ul>"},{"location":"demo/#operator-based-deployment","title":"Operator based deployment","text":"<p>There are several ways to install Event Streams. We are going to look at this, with Operator Hub. </p> <ol> <li> <p>Go to your Openshift console, select Operator Hub and search for Event Streams. Here you can install the operator to manage all cluster instances deployed to the OpenShift environment. Operator can automatically deploy new product version once released by IBM.</p> <p></p> </li> <li> <p>In the OpenShift Console, select the project where Event Streams is deployed. On left menu select <code>Operators &gt; Installed Operators</code>, scroll to select IBM Event Streams, you are now in the Operator user interface, from where you can see local resources and create new one.</p> <p></p> </li> <li> <p>Go to the <code>Event Streams</code> menu and select existing cluster definition</p> <p></p> </li> <li> <p>You are now viewing the cluster definition as it is deployed. Select the <code>YAML</code> choice and see the <code>spec</code> elements. </p> <p></p> <p>You can see how easy it would be simple to add a broker by changing the <code>spec.strimziOverrides.kafka.replicas</code> value. Also in this view, the <code>Samples</code> menu presents some examples of cluster definitions. Kafka brokers, Zookeeper nodes or other components like Apicurio can all be scaled to meet your needs: </p> <ul> <li>Number of replicas</li> <li>CPU request or limit settings</li> <li>Memory request or limit settings</li> <li>JVM settings</li> </ul> </li> <li> <p>On the left side menu select Workloads-&gt;Pods. Here you see pods that are in the Event Streams namespace like  Broker, zookeepers, user interface, schema registry:</p> <p></p> </li> <li> <p>If needed, you can explain the concept of persistence and Storage class: Kafka save records on disk for each broker, and so it can use VM disk or network file systems. As Kubernetes deployed application, Event Streams define persistence via persistence claim and expected quality of service using storage class.</p> <p></p> <p>On the left side menu select, <code>Storage &gt; PersistenceVolumesClaims</code> in the OpenShift console, each broker has its own claim, OpenShift allocated Persistence Volumes with expected capacity. The Storage class was defined by OpenShift administrator, and in the example above, it use CEPH storage.</p> </li> </ol> Read more <ul> <li>Cepth and block devise</li> <li>Kafka Brokers and architecture</li> <li>GitOps approach for Day1 and Day 2 operations</li> </ul>"},{"location":"demo/#review-event-streams-user-interface-features","title":"Review Event Streams user interface features","text":"<p>There are a number of ways to navigate to Event Streams Console by getting the exposed routes</p> <ol> <li> <p>Using Routes in Openshift: On the left side menu select <code>Networking &gt; Routes</code> in the OpenShift console. Find <code>es-demo-ibm-es-ui</code> and then go to Location. Select that link and it will take you to the Event Streams Console. Depending to your installation, you may reach Cloud Pak for Integration console, in this case, select Entreprise LDAP, and enter your userid and password.</p> <p></p> </li> <li> <p>Using the cli:  (replace <code>es-demo</code> with the name of your cluster, and <code>cp4i-eventstreams</code> with the name of the project where Event Streams runs into )</p> <pre><code>chrome $(oc get eventstreams es-demo -n cp4i-eventstreams -o jsonpath='{.status.adminUiUrl}')\n</code></pre> <p>Once you logged in using the LDAP credentials provided, you should reach the home page.</p> <p></p> </li> <li> <p>The set of features available from this home page, are topic management, schema registry, consumer groups, monitoring, and toolbox... you will review most of those features in this demo.</p> </li> </ol>"},{"location":"demo/#topic-management","title":"Topic management","text":"<p>Topics are append log, producer applications publish records to topics, and consumer applications subscribe to topics. Kafka messages themselves are immutable. Deletion and compaction of data are administrative operations.</p> <ol> <li> <p>Navigate to the topic main page by using the Event Streams left side menu and select Topics.</p> <p></p> <ul> <li>replicas are to support record replication and to ensure high availability. Producer can wait to get acknowledgement of replication. Replicas needs to be set to 3 to supports 2 broker failures at the same time. </li> <li>partition defines the number of append logs managed by the broker. Each partition has a leader, and then follower brokers that replicate records from the leader. Partitions are really done to do parallel processing at the consumer level. </li> <li>The following diagram can be used to explain those concepts. </li> </ul> <p></p> </li> <li> <p>Create a topic for the Starter app, using the user interface:</p> <p>Warning</p> <p>When running on a multi-tenant Event Streams cluster you need to modify the name of the topic, to avoid conflicting with other topic name, use your userid as prefix.</p> <p></p> <p>Use only one partition.</p> <p></p> <p>The default retention time is 7 days, Kafka is keeping data for a long time period, so any consumer applications can come and process messages at any time. It helps for microservice resilience and increase decoupling.</p> <p></p> <p>Finally the replicas for high availability. 3 is the production deployment, and in-sync replicas = 2, means producer get full acknowledge when there are 2 replicas done. Broker partition leader keeps information of in-sync replicas.</p> <p></p> </li> <li> <p>Just as an important note, topic may be created via yaml file or using CLI command. Go to the rt-inventory GitOps - es-topics.yaml and explain some of the parameters.</p> </li> <li> <p>We will go over the process of adding new topic by using GitOps in this section</p> </li> </ol> Read more <ul> <li>Topic summary</li> <li>Kafka topic configuration</li> <li>Understand Kafka producer</li> <li>Review Consumer</li> <li>Replication and partition leadership</li> </ul>"},{"location":"demo/#run-the-starter-application","title":"Run the Starter Application","text":"<p>See the beginned dedicated lab to get the application started, once done:</p> <ol> <li> <p>Go back to the Event Streams console, Topic management, and the <code>starter-app</code> topic, select the <code>Messages</code> tab and go to any messages. Explain that each messages has a timestamp, and an offset that is an increasing number.  Offset are used by consumer to be able to replay from an older message, or when restarting from a failure. Offset management at the consumer application level is tricky, if needed you can have a deeper conversation on this topic later after the demonstration.</p> <p></p> </li> <li> <p>At the topic level, it is possible to see the consumer of the topic: Go to the <code>Consumer groups</code> tab, to see who are the consumer, if the consumer is active or not (this will be controlled by the heartbeat exchanges when consumer poll records and commit their read offset). </p> <p></p> <p>One important metric in this table is the unconsumed partition value. If the number of partitions is more than 1 and there are less than the number of consumer than of partition, then it means a consumer is processing two or more partitions.</p> </li> <li> <p>Going by to the starter application, you can start consuming the records. This is to demonstrate that consumer can connect at anytime, and that it will quickly consume all messages. Stopping and restarting is also demonstrating that consumer, continues from the last read offset.</p> </li> </ol> <p>There is an alternate of running this application on your laptop, it can be deployed directly to the same OpenShift cluster, we have defined <code>deployment and config map</code> to do so.</p> Deploy starter app on OpenShift <ul> <li>Use the same <code>kafka.properties</code> and <code>truststore.p12</code> files you have downloaded with the starter application to create two kubernetes secrets holding these files in your OpenShift cluster</li> </ul> <pre><code>oc create secret generic demo-app-secret --from-file=./kafka.properties\noc create secret generic truststore-cert --from-file=./truststore.p12\n</code></pre> <ul> <li>Clone the following GitHub repo that contains the Kubernetes artifacts that will run the starter application.</li> </ul> <pre><code>git clone https://github.com/ibm-cloud-architecture/eda-quickstarts.git\n</code></pre> <ul> <li>Change directory to where those Kubernetes artefacts are.</li> </ul> <pre><code>cd eda-quickstarts/kafka-java-vertz-starter\n</code></pre> <ul> <li>Deploy the Kubernetes artefacts.</li> </ul> <pre><code>oc apply -k app-deployment\n</code></pre> <ul> <li>Get the route to the starter application running on your OpenShift cluster.</li> </ul> <pre><code>oc get route es-demo -o=jsonpath='{.status.ingress[].host}'\n</code></pre> <ul> <li>Point your browser to that url to work with the IBM Event Streams Starter Application.</li> </ul>"},{"location":"demo/#back-to-the-cluster-configuration","title":"Back to the Cluster configuration","text":"<p>Event Streams cluster can be configured with Yaml and you can review the following cluster definition to explain some of the major properties:  EDA GitOps Catalog - example of production cluster.yaml:</p> Property Description Replicas specify the # of brokers or zookeeper Resources CPU or mem requested and limit Listeners Define how to access the cluster: External with scram authentication and TLS encryption, and internal using TLS authentication or PLAIN. Entity operators Enable topic and user to be managed by operator Rack awareness To use zone attribute from node to allocate brokers in different AZ Cruise Control Open source for cluster rebalancing Metrics To export different Kafka metrics to Prometheus via JMX exporter <p>For Kafka, the following aspects of a deployment can impact the resources you need:</p> <ul> <li>Throughput and size of messages</li> <li>The number of network threads handling messages</li> <li>The number of producers and consumers</li> <li>The number of topics and partitions</li> </ul>"},{"location":"demo/#producing-messages","title":"Producing messages","text":"<p>The product documentation - producing message section goes into details of the concepts.  For a demonstration purpose, you need to illustrate that you can have multiple types of Kafka producer:</p> <ul> <li>Existing Queuing apps, which are using IBM MQ, and get their messages transparently sent to Event Streams, using IBM MQ Streaming Queue and MQ Source Kafka Connector.</li> </ul> <p></p> <ul> <li>Microservice applications publishing events using Kafka producer API, or reactive messaging in Java Microprofile. For Nodejs, Python there is a C library which supports the Kafka APIs. We have code template for that.</li> <li>Change data capture product, like Debezium, that gets database updates and maps records to events in topic. One topic per table. Some data transformation can be done on the fly.</li> <li>Streaming applications, that do stateful computing, real-time analytics, consuming - processing - publishing events from one to many topics and produce to one topic. </li> <li>App connect flow can also being source for events to Events Streams, via connectors.</li> </ul> <p>The following diagram illustrates those event producers.</p> <p></p> <p>Each producer needs to get a URL to the broker, defines the protocol to authenticate, and gets server side TLS certificate, the topic name, and that's it to start sending messages.</p> <p>For production deployment, event structures are well defined and schema are used to ensure consumer can understand how to read messages from the topic/partition. Event Streams offers a schema registry to manage those schema definitions.</p> <p>You can introduce the schema processing with the figure below:</p> <p></p> Schema flow explanations <ul> <li>(1) Avro or Json schemas are defined in the context of a producer application. As an example you can use the OrderEvent.avsc in the EDA quickstart project. </li> <li>They are uploaded to Schema registry, you will demonstrate that in 2 minutes</li> <li>(2) Producer application uses Serializer that get schema ID from the registry </li> <li>(3) Message includes metadata about the schema ID</li> <li>(4) So each message in a topic/partition may have a different schema ID, which help consumer to be able to process old messages</li> <li>(5) Consumers get message definitions from the central schema registry.</li> </ul>"},{"location":"demo/#schema-registry","title":"Schema registry","text":"<p>This is really an introduction to the schema management, a deeper demo will take around 35 minutes and is described in this EDA lab</p> <ol> <li> <p>Get the ItemEvent schema definition (Defined in the context of the real-time inventory demo) using the command below:</p> <pre><code>    curl https://raw.githubusercontent.com/ibm-cloud-architecture/refarch-eda-store-simulator/master/backend/src/main/avro/ItemEvent.avsc &gt; ItemEvent.avsc\n</code></pre> <p>Warning</p> <p>When running on a multi-tenant Event Streams cluster you need to modify the name of the schema name, to avoid conflicting with other schema name in the registry. In the context of the <code>IBM Tech Academy</code>, we propose you prefix the name with your assigned user-id.</p> </li> <li> <p>Go to the Schema registry in the Event Streams console, and click to <code>Add Schema</code></p> <p></p> </li> <li> <p>In the <code>Add schema</code> view, select <code>Upload definition</code>, select the <code>ItemEvent.avsc</code></p> <p></p> </li> <li> <p>The first ItemEvent schema is validated, </p> <p></p> </li> <li> <p>You can see its definition too</p> <p></p> </li> <li> <p>Do not forget to press <code>Add schema</code> to save your work. Now the schema is visible in the registry</p> <p></p> </li> </ol> <p>Now any future producer application discussions should be around level of control of the exactly once, at most once delivery, failover and back preasure. This is more complex discussion, what is important to say is that we can enforce producer to be sure records are replicated before continuing, we can  enforce avoiding record duplication, producer can do message buffering and send in batch, so a lot of controls are available depending of the application needs.</p> Reading more <ul> <li>Producer best practices and considerations</li> <li>Using the outbox pattern with Debezium and Quarkus</li> <li>DB2 debezium lab</li> <li>Playing with Avro Schema</li> <li>Event Streams product documentation</li> </ul>"},{"location":"demo/#consumer-application-consumer-group","title":"Consumer application - consumer group","text":"<p>Let\u2019s take a look at consumer group and how consumer gets data from Topic/partition. The following figure will help supporting the discussion:</p> <p></p> Explanations <ul> <li>Consumer application define a property to group multiple instances of those application into a group.</li> <li>Topic partitions are only here to support scaling consumer processing</li> <li>Brokers are keeping information about group, offset and partition allocation to consumer </li> <li>When a consumer is unique in a group, it will get data from all partitions.</li> <li>We cannot have more consumer than number of topic, if not the consumer will do nothing</li> <li>Membership in a consumer group is maintained dynamically</li> <li>When the consumer does not send heartbeats for a duration of <code>session.timeout.ms</code>, then it is considered unresponsive and its partitions will be reassigned.</li> <li>For each consumer group, Kafka remembers the committed offset for each partition being consumed.</li> <li>Understanding offset</li> <li>Get more details on consumer best practices</li> </ul> <p>Recall that offset is just a numeric identifier of a consumer position of the last record read within a partition. Consumers periodically need to commit the offsets they have received, to present a recovery point in case of failure.</p> <p>For reliable consumers, it means the commitment of the read offset is done by code once the consumer is done with its processing. There is an important limitation within App Connect Kafka consumer node as there is no way to commit by code, so do not propose App Connect as a viable solution if you need to do not loose message. Or support adding new java custom code to do the management of offset.</p> <p>From Event Streams demonstration point of view, we can only demonstrate consumer groups for a given topic, and if consumers are behind in term of reading records from a partition.</p> <ol> <li> <p>In the Event Streams console go to the <code>Topics</code> view and <code>Consumer Groups tab</code> of one of the topic. The figure below shows that there is no active member for the consumer groups , and so one partition is not consumed by any application.</p> <p></p> </li> <li> <p>Another view is in the <code>Consumer Groups</code> which lists all the consumer groups that have been connected to any topic in the cluster: This view helps to assess if consumer are balanced. Selecting one group will zoom into the partition and offset position for member of the group. Offset lag is what could be a concern. The consumer lag for a partition is the difference between the offset of the most recently published message and the consumer's committed offset.</p> <p></p> <p>Consumer lag may show that consumers are not processing records at the same pace that producer is publishing them. This could not be a problem, until this lag is becoming too high and compaction or retention by time or size will trigger, removing old records. In this case consumers will miss messages.</p> </li> </ol> Reading more <ul> <li>Review Consumer</li> <li>Product documentation - Consuming messages</li> </ul>"},{"location":"demo/#user-management-and-security","title":"User management and security","text":"<p>There are two types of user management in Event Streams: the human users, to access the user interface and the application users to access Brokers and Kafka Topics.</p> <p>Application users are defined with KafkaUser custom resources. The Yaml also describes access control list to the topic. The following KafkaUser yaml file is an example of application user used to authenticate with mutual TLS.</p> <p>Such user can also being created by using the <code>connect to the cluster</code> option in Event Streams console.</p> <p>The Acces Control Lists are defined by specifying the resource type and the type of operation authorized. User certificates and passwords are saved in secrets. The ACL rules define the operations allowed on Kafka resources based on the username:</p> <pre><code>acls:\n- resource:\ntype: topic   name: 'rt-'\npatternType: prefix\noperation: Write\n- resource:\ntype: topic\nname: '*'\npatternType: literal\noperation: Read\n- resource:\ntype: topic\nname: '*'\npatternType: literal\noperation: Create\n</code></pre> <p>For human authentication, users are defined using IBM Cloud Pak foundational services Identity and Access Management (IAM). Things to keep in mind:</p> <ul> <li>IAM is in Cloud Pak | Administation console. A URL like: https://cp-console.apps........ibm.com/common-nav/dashboard</li> <li> <p>Need to define a team for resources, administrator users... using he Administration console and IAM menu:</p> <p></p> <p>Define new team, with connection to an active directory / identity provider:</p> <p></p> </li> <li> <p>Any groups or users added to an IAM team with the <code>Cluster Administrator</code> or <code>Administrator</code> role can log in to the Event Streams UI and CLI</p> <p></p> <p>or non admin user:</p> <p></p> </li> <li> <p>Any groups or users with the Administrator role will not be able to log in until the namespace that contains the Event Streams cluster is added as a resource for the IAM team.</p> <p></p> </li> <li> <p>If the cluster definition includes <code>spec.strimziOverrides.kafka.authorization: runas</code>, users are mapped to a Kafka principal </p> </li> </ul> Read more <ul> <li>Managing access - product documentation </li> <li>Managing team with IAM</li> <li>ACL and authorization</li> <li>ACLs rule schema reference </li> </ul>"},{"location":"demo/#kafka-connect","title":"Kafka Connect","text":"<p>Kafka connect is used to connect external systems to Event Streams brokers. For production deployment the Kafka connect connectors run in cluster, (named distributed mode), to support automatic balancing, dynamic scaling and fault tolerance. In the figure below, we can see Kafka Connect cluster builds with 3 worker processes. The configuration if such worker is done with one file, that can be managed in your GitOps. (An example of such file is here) </p> <p></p> <p>Event Streams Operator supports custom resource to define Kafka connect cluster. Each connector is represented by another custom resource called KafkaConnector.</p> <p>When running in distributed mode, Kafka Connect uses three topics to store configuration, current offsets and status.</p> <p>Once the cluster is running, we can use custom resource to manage the connector. For example to get a MQ Source connector definition example, you can browse this yaml which specifies how to connect to the MQ broker and how to create records for Kafka.</p> <pre><code>apiVersion: eventstreams.ibm.com/v1alpha1\nkind: KafkaConnector\nmetadata:\nname: mq-source\nlabels:\neventstreams.ibm.com/cluster: eda-kconnect-cluster\nspec:\nclass: com.ibm.eventstreams.connect.mqsource.MQSourceConnector\ntasksMax: 1\nconfig:\nmq.queue.manager: QM1\nmq.connection.name.list: store-mq-ibm-mq.rt-inventory-dev.svc\nmq.channel.name: DEV.APP.SVRCONN\nmq.queue: ITEMS\nmq.bath.size: 250\nproducer.override.acks: 1\ntopic: items\nkey.converter: org.apache.kafka.connect.storage.StringConverter\nvalue.converter: org.apache.kafka.connect.storage.StringConverter\nmq.record.builder: com.ibm.eventstreams.connect.mqsource.builders.DefaultRecordBuilder\nmq.connection.mode: client\nmq.message.body.jms: true\nmq.record.builder.key.header: JMSCorrelationID\n</code></pre> <p>to improve connector source throughput we can control the producer properties like the acknowledge level expected.</p> <p>The real time inventory demo includes MQ source connector.</p> Read more <ul> <li>Event Streams documentation - kafka connect</li> <li>Kafka Connect technology deeper dive</li> </ul>"},{"location":"demo/#monitoring","title":"Monitoring","text":"<p>The IBM Event Streams UI provides information about the health of your environment at a glance. In the bottom right corner of the UI, a message shows a summary status of the system health.</p> <ul> <li>Using the JMX exporter, you can collect JMX metrics from Kafka brokers, ZooKeeper nodes, and Kafka Connect nodes, and export them to Prometheus</li> </ul> <p>Warning</p> <p>Be aware IBM Cloud Pak foundational services 3.8 and later does not include Prometheus so you will get Event Streams metrics not available error message. On Biggs as of 04/19/22, the cluster configuration was done. If you need to do it on your cluster see those two files: cluster-monitoring-cm.yaml to enable user workload monitoring with Prometheus and pod-monitors.yaml to declare the PodMonitor to define scrapeable endpoints of a Kubernetes Pod serving Prometheus metrics.</p> <ol> <li> <p>Assess Event Streams cluster state: Go to the project where the cluster runs, select one of the Kafka Pod. You can see the pod via the OpenShift workloads menu, or by using the Event Streams Operator &gt; Resources and then filter on pods:</p> <p></p> <p>Select one of the pods and go to the metrics to see memory, CPU, network and filesystem usage metrics.</p> <p></p> </li> <li> <p>Access the Cloud Pak | Administration console to select Monitoring</p> <p></p> </li> <li> <p>Switch organization to select where <code>Event Streams</code> is running</p> <p></p> </li> <li> <p>Then go to the grafana Dashboard menu on the left &gt; Manage and select event streams dashboard</p> <p></p> </li> <li> <p>In the Grafana dashboard select the namespace for event streams  (e.g. <code>cp4i-eventstreams</code>), the cluster name (<code>es-demo</code>), the brokers, and the topic to monitor.  </p> <p></p> </li> </ol> More reading <ul> <li>Product documentation</li> <li>EDA monitoring study</li> <li>Event Streams Monitoring on OpenShift lab</li> <li>Creating alert from Prometheus</li> </ul>"},{"location":"demo/#event-streaming","title":"Event Streaming","text":""},{"location":"demo/#kafka-streams","title":"Kafka Streams","text":"<p>Kafka Streams is client API to build microservices with input and output data are in Kafka. It is based on programming a graph of processing nodes to support the business logic developer wants to apply on the event streams.</p>"},{"location":"demo/#apache-flink-as-your-streaming-platform","title":"Apache Flink as your streaming platform","text":"<p>To be done.</p>"},{"location":"demo/#real-time-inventory-demo","title":"Real-time inventory demo","text":"<p>It is possible to propose a more complex solution to illustrate modern data pipeline using components like  MQ source Kafka Connector, Kafka Streams implementation and Cloud Object Storage sink, Elastic Search and Pinot.</p> <p>This scenario implements a simple real-time inventory management solution based on some real life MVPs we developed in 2020.  For a full explanation of the use case and scenario demo go to this chapter in EDA reference architecture.</p> <p></p> <p>The solution can be deployed using few commands or using GitOps. </p> <p>See Lab3-4</p> More Reading <ul> <li>Description of the scenario and demo script</li> <li>GitOps project to deploy the solution</li> <li>EDA GitOps Catalog to deploy Cloud Pak for Integration operators</li> </ul>"},{"location":"demo/#geo-replication","title":"Geo-replication","text":"<p>We will go over two main concepts: replication to a passive and active Event Streams cluster. Geo Replication is the IBM packaging of Mirror Maker 2. </p>"},{"location":"demo/#demonstrating-geo-replication","title":"Demonstrating Geo Replication","text":"<p>The geo-replication feature creates copies of your selected topics to help with disaster recovery.</p>"},{"location":"demo/#mirror-maker-2","title":"Mirror Maker 2","text":"<p>Mirror Maker 2 is a Kafka Connect framework to replicate data between different Kafka Cluster, so it can be used between Event Streams clusters, but also between Confluent to/from Event Streams, Kafka to/from Event Streams...</p> <p>The following diagram can be used to present the MM2 topology</p> <p></p>"},{"location":"demo/#active-passive","title":"Active - Passive","text":"<p>See a demonstration for the real-time inventory and replication in this article</p> <p></p>"},{"location":"demo/#active-active","title":"Active - Active","text":"Read more <ul> <li>Geo Replication - Product documentation</li> <li>EDA techno overview for Mirror Maker 2</li> <li>Demonstration in the context of real-time inventory</li> <li>EDA lab on mirror maker 2</li> </ul>"},{"location":"demo/#day-2-operations","title":"Day 2 operations","text":"<p>In this section, you should be able to demonstrate some of the recurring activities, operation team may perform for the Event Streams and OpenShift platform for maintenance:</p> <ul> <li>Change Cluster configuration</li> <li>Add topic or change topic configuration like adding partition</li> </ul>"},{"location":"demo/#gitops","title":"GitOps","text":"<p>The core idea of GitOps is having a Git repository that always contains declarative descriptions of the infrastructure currently desired in the production environment and an automated process to make the production environment matches the described state in the repository. Git is the source of truth for both application code, application configuration, dependant service/product deployments, infrastructure config and deployment.</p> <p>In the following figure, we just present the major components that will be used to support GitOps and day 2 operations: </p> <p></p> Explanations <ul> <li>cluster configuration, topics, users ACL are defined as yaml resources in the solution GitOps. Cluster example for prod</li> <li>(1) Operator definitions are also defined in the gitops and then change to the version subscription will help do product upgrade. Event Streams subscription with overlays for a new version.</li> <li>(2) ArgoCD apps are defined in the GitOps and then once running on the GitOps Server, will monitor changes to the source gitOps content </li> <li>(3) when change occurs, the underlying kubernetes resources are modified</li> <li>(4) Operator maintains control to the runtime pods according to the modified manifest</li> </ul> <p>Cloud Pak for integration, event streams, MQ, API Connect operators help to support deployment as a Day 1 operation, but also support maintenance or Day 2 operations. Operator is constantly watching your cluster\u2019s desired state for the software installed and act on them.</p> <p>Using a GitOps approach, we can design a high-level architecture view for the deployment of all the event-driven solution components: as in previous figure, operators, ArgoCD apps, cluster, topics... are defined in the solution gitops and then the apps deployment, config map, service, secrets, routes are also defined according to the expected deployment model.</p> <p></p> <p>In the figure above, the dev, and staging projects have their own Event Streams clusters. Production is in a separate OpenShift Cluster and event streams cluster is multi-tenant.</p> <p>We are using a special Git repository to manage a catalog of operator definitions/ subscriptions. This is the goal of the eda-gitops-catalog repository.</p> <p>A solution will have a specific gitops repository that manages services (operands) and application specifics deployment manifests.</p>"},{"location":"demo/#start-the-gitops-demo","title":"Start the GitOps demo","text":"<p>Warning</p> <p>In the context of the Tech academy, if you want to use Gitops you should use the lab 4 exercise as it is a little bit simpler than to execute next section.</p> <p>To be able to do continuous deployment we need to have some ArgoCD apps deployed on GitOps server.  In all gitOps demos, we assume you have a fork of the eda-rt-inventory-gitops. </p> <p>If you are not using a cluster with Event Streams already installed in the <code>cp4i-eventstreams</code>, you may need to modify the Copy Secret job () so it can get the <code>ibm-entitlement-key</code> from the good namespace.</p> <ol> <li> <p>If not done yet, jumpstart GitOps</p> <p><pre><code>oc apply -k demo/argocd\n</code></pre> 1. Access to the ArgoCD console</p> <p><pre><code> chrome https://$(oc get route openshift-gitops-server -o jsonpath='{.status.ingress[].host}'  -n openshift-gitops)\n</code></pre> 1. User is <code>admin</code> and password is the result of </p> <pre><code>oc extract secret/openshift-gitops-cluster -n openshift-gitops --to=-\n</code></pre> </li> <li> <p>You should have two apps running in the default scope/ project.</p> <p></p> <p>The argocd apps are monitoring the content of the demo/ env folder and once deployed, you should have a simple Event Streams node with one zookeeper under the project <code>es-demo-day2</code>.</p> </li> </ol>"},{"location":"demo/#event-streams-cluster-definition-with-gitops","title":"Event Streams cluster definition with GitOps","text":"<p>The goal of this section is to demonstrate how to define an Event Stream cluster with configuration and change the number of replicas. This is a very simple use case to try to use the minimum resources. So the basic cluster definition use 1 broker and 1 zookeeper.  The file is es-demo.yaml. it is using Event Streams version 10.5.0 and one replicas</p> <ol> <li> <p>In GitOps console, if you go to the demo-env app, you will see there is one Kafka broker and also a lot of Kubernetes resources defined</p> <p></p> </li> <li> <p>In the <code>es-demo-day2</code> project, use <code>oc get pods</code> to demonstrate the number of brokers</p> <pre><code>NAME                                    READY   STATUS      RESTARTS   AGE\ncpsecret-48k2c                          0/1     Completed   0          11m\ndemo-entity-operator-558c94dc57-lxp6s   3/3     Running     0          24m\ndemo-ibm-es-admapi-6678c47b95-hg82v     1/1     Running     0          14m\ndemo-ibm-es-metrics-b974c7585-jpfc7     1/1     Running     0          14m\ndemo-kafka-0                            1/1     Running     0          24m\ndemo-zookeeper-0                        1/1     Running     0          25m\n</code></pre> </li> <li> <p>Modify the number of replicas</p> <pre><code>    kafka:\nreplicas: 2\n</code></pre> </li> <li> <p>Commit and push your changes to your git repository and see ArgoCD changing the configuration, new pods should be added.</p> </li> <li> <p>You can enforce a refresh to get update from Git and then navigate the resources to see the new brokers added (demo-kafka-1):</p> <p></p> </li> </ol> <p>Adding a broker will generate reallocation for topic replicas.</p>"},{"location":"demo/#event-streams-cluster-upgrade","title":"Event Streams Cluster upgrade","text":"<p>This will be difficult to demonstrate but the flow can be explain using the OpenShift Console.</p> <ol> <li>First you need to be sure the cloud pak for integration services are upgraded. (See this note)</li> <li> <p>Two things to upgrade in this order: Event Streams operator and then the cluster instances.</p> <p>You can upgrade the Event Streams operator to version 2.5.2 directly from version 2.5.x, 2.4.x, 2.3.x, and 2.2.x..</p> <p>You can upgrade the Event Streams operand to version 11.0.0 directly from version 10.5.0, 10.4.x</p> </li> <li> <p>Start by presenting the version of an existing running Cluster definition</p> <p></p> </li> <li> <p>May be show some messages in a topic, for example the Store Simulator may have sent messages to the <code>items</code> topic</p> </li> <li> <p>Go to the <code>openshift-operators</code> and select the event streams operator, explain the existing chaneel then change the channel number</p> <p></p> <p></p> <ul> <li>Event Streams instance must have more than one ZooKeeper node or have persistent storage enabled.</li> <li>Upgrade operator is by changing the channel in the operator subscription. All Event Streams pods that need to be updated as part of the upgrade will be gracefully rolled. Where required ZooKeeper pods will roll one at a time, followed by Kafka brokers rolling one at a time.</li> </ul> </li> <li> <p>Update the cluster definition version to new version (10.5.0 in below screen shot), thne this will trigger zookeeper and kafka broker update.</p> <p></p> </li> </ol> <p>The goal of this section is to demonstrate how to change topic definition using Argocd and git.</p> <ol> <li> <p>Modify the file es-topic.yaml by adding a new topic inside this file with the following declaration:</p> <pre><code>apiVersion: eventstreams.ibm.com/v1beta1\nkind: KafkaTopic\nmetadata:\nname: demo-2-topic\nlabels:\neventstreams.ibm.com/cluster: demo\nspec:\npartitions: 1 replicas: 1\n</code></pre> </li> <li> <p>Commit and push your changes to your git repository and see ArgoCD changing the configuration, new pods should be added.</p> </li> <li>Do <code>oc get kafkatopics</code> or go to Event Streams operator in the <code>es-demo-day2</code> project to see all the Event Streams component instances.</li> </ol>"},{"location":"demo/#topic-management-with-gitops","title":"Topic management with GitOps","text":""},{"location":"demo/#repartitioning","title":"Repartitioning","text":"<ol> <li> <p>You can demonstrate how to change the number of partition for an existing topic (<code>rt-items</code>) from 3 to 5 partitions:</p> <pre><code>oc apply -f environments/rt-inventory-dev/services/ibm-eventstreams/base/update-es-topic.yaml\n</code></pre> </li> <li> <p>Add more instances on the consumer part: taking the <code>store-aggregator</code> app and add more pods from the deployment view in OpenShift console, or change the deployment.yaml descriptor and push the change to the git repository so GitOps will catch and change the configuration:</p> <p></p> <pre><code># modify https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/blob/main/environments/rt-inventory-dev/apps/store-inventory/services/store-inventory/base/config/deployment.yaml\noc apply -f environments/rt-inventory-dev/apps/store-inventory/services/store-inventory/base/config/deployment.yaml\n</code></pre> </li> </ol> Read more <ul> <li>Event Streams doc on Kafka tools mapping to cli</li> </ul>"},{"location":"demo/#clean-your-gitops","title":"Clean your gitops","text":"<ul> <li>Remove the ArgoCD apps</li> </ul> <pre><code>oc delete -k demo/argocd </code></pre> <ul> <li>Remove resources</li> </ul> <pre><code> oc delete -k demo/env\n</code></pre> Read more <ul> <li>Event driven solution with GitOps</li> <li>EDA GitOps Catalog</li> <li>Real time inventory demo gitops</li> </ul>"},{"location":"demo/#openshift-cluster-version-upgrade","title":"OpenShift Cluster version upgrade","text":"<p>There may be some questions around how to migrate a version for OCP. </p>"},{"location":"demo/#principles","title":"Principles","text":"<p>For clusters with internet accessibility, Red Hat provides over-the-air updates through an OpenShift Container Platform update service as a hosted service located behind public APIs.</p> <p>Due to fundamental Kubernetes design, all OpenShift Container Platform updates between minor versions must be serialized.</p>"},{"location":"demo/#what-can-be-demonstrated","title":"What can be demonstrated","text":"<p>At the demo level, you can go to the Administration console in <code>Administration &gt; Cluster Settings</code> you get something like this:</p> <p></p> <ul> <li> <p>If you want to upgrade version within the same release</p> <p></p> </li> <li> <p>Or upgrade release change the Channel version:</p> <p></p> </li> </ul> <p>As the operation will take sometime, it is not really demonstrable easily. </p> Read more <ul> <li>Openshift understanding upgrade channels release</li> <li>Canary rollout</li> </ul>"},{"location":"getting-started/","title":"Getting started with Event Streams","text":""},{"location":"getting-started/#introduction-and-getting-started","title":"Introduction and Getting Started","text":"<p>Ty Harris </p> <p>IBM Event Streams is based on years of operational expertise that IBM has gained from running Apache Kafka\u00ae for enterprises. IBM Event Streams offers enterprise-grade security, scalability, and reliability running on Red Hat\u00ae OpenShift\u00ae Container Platform as certified container software. Building an event-driven architecture with IBM Event Streams allows organizations to transition from traditional monolith systems and silos to modern micro-services and event streaming applications that increase their agility and accelerate their time to innovation.</p> <p>IBM Event Streams builds on top of open-source Apache Kafka\u00ae to offer enterprise-grade event streaming capabilities. The following features are included as part of IBM Event Streams:</p> <ul> <li>Identity and Access Management (IAM) offers fine-grain security controls to manage the access that you want to grant each user for Kafka clusters, Topics, Consumer Groups, Producers, and more.</li> <li>Geo-replication enables the deployment of multipleEvent Stream instances in different locations and thesynchronization ofdata between your clusters to improve service availability.</li> <li>Visual driven management and monitoring experience with the Event Streams dashboard that displays metrics collected from the cluster, Kafka brokers, messages, consumers, and producers to provide health check information and options to resolve issues</li> </ul> <p>IBM Event Streams enables you to adopt event-driven architectures.</p>"},{"location":"getting-started/#lab-objective","title":"Lab Objective","text":"<p>The objective of this lab is to demonstrate the step-by-step process to download and install our Starter Apache Kafka application. The starter application provides a demonstration of a Java application that uses the Vert.x Kafka Client to send and receive events from Event Streams. The starter application also includes a user interface to easily view message propagation. The source code is provided in GitHub to allow you to understand the elements required to create your own Kafka application.</p> <p>App details: https://ibm.github.io/event-automation/es/getting-started/generating-starter-app/</p> <p>Warning</p> <p>The API keys generated for the starter application can only be used to connect to the topic selected during generation. In addition, the consumer API key can only be used to connect with a consumer group ID set to the name of the generated application.</p>"},{"location":"getting-started/#environment-used-for-this-lab","title":"Environment used for this lab","text":"<ol> <li>IBM Cloud Pak for Integration </li> <li>Red Hat Openshift Container Platform</li> <li>IBM Event Streams version 11.x</li> <li>Apache Kafka 3.2</li> <li>Java version 17</li> </ol>"},{"location":"getting-started/#lab-environment-pre-requisites","title":"Lab Environment Pre-Requisites","text":"<ul> <li>The Cloud Pak for Integration has been deployed and the access credentials are available.</li> <li>Java version 17 installed on local environment. Use the IBM Semeru Runtimes Downloads site to download Java</li> <li>Apache Maven Installed on local environment (Optional).</li> </ul>"},{"location":"getting-started/#getting-started-with-ibm-event-streams","title":"Getting started with IBM Event Streams","text":"<ol> <li> <p>Click on one of the link below (depending on the OpenShift cluster allocated to you) to log into your Event Streams instance using the student credentials provided. Once you've logged in, you'll see the Event Streams homepage.</p> Host URL Ventress https://cpd-cp4i.apps.ventress.coc-ibm.com/integration/kafka-clusters/event-automation/my-kafka-cluster/ Melch https://cpd-cp4i.apps.melch.coc-ibm.com/integration/kafka-clusters/event-automation/my-kafka-cluster/ POE https://cpd-cp4i.apps.poe.coc-ibm.com/integration/kafka-clusters/event-automation/my-kafka-cluster/ <p></p> </li> <li> <p>Select \u201cTry the starter application\u201d tile.</p> <p></p> </li> <li> <p>Create a working directory on your local drive then select the \u201cDownload JAR from GitHub\u201d tab. You\u2019ll want the <code>demo-all.jar</code> file for release 1.1.3. </p> <p></p> </li> <li> <p>Copy the downloaded .jar file to your working directory.</p> <p></p> </li> <li> <p>Now let\u2019s generate and download our properties file. Select the \u201cGenerate properties\u201d tab. </p> <p></p> </li> <li> <p>Enter a name of your app. For guidance, the prefix should be your login ID similar to the example below (i.e. cody1app). This will help us identify which apps are running and who is the owner. Select the \u201cNew topic\u201d tab and enter a topic name. Again, use your login ID as the prefix for your topic name. Now select the \u201cGenerate and download .zip\u201d tab.</p> <p></p> </li> <li> <p>Extract the downloaded .zip file in your working directory. Copy the properties file and p12 file to your working directory. Make sure <code>demo-all.jar</code>, <code>kafka.properties</code> and <code>truststore.p12</code> are all in the same directory. </p> <p></p> </li> <li> <p>Open a terminal and navigate to your working directory. Enter the following command:</p> <pre><code>java -Dproperties_path=./ -jar demo-all.jar\n</code></pre> <p></p> </li> <li> <p>After your applications starts, open a browser, and enter:</p> <pre><code>http://localhost:8080 </code></pre> <p></p> </li> <li> <p>Select the \u201cStart Producing\u201d and \u201cStart Consuming\u201d tabs. </p> <p></p> </li> <li> <p>You should soon see messages being produced and consumed.  </p> <p></p> </li> <li> <p>Now, let\u2019s check our Event Streams cluster to verify our topic creation and monitoring of the messages. To do this, go back to the Event Streams homepage. Select \u201cToolbox\u201d.</p> <p></p> </li> <li> <p>Select \u201cHome\u201d to go to the EventStreams homepage.</p> <p></p> </li> <li> <p>Select \u201cTopics\u201d to see the topic you created in the Starter application. Click on your topic to see the Producers, Messages and Consumers.</p> </li> </ol> <p>Congratulations! You have successfully run your starter application.</p>"},{"location":"getting-started/#learning-summary","title":"Learning summary","text":"<p>In summary, you have learned the following in this lab:</p> <ul> <li>Run an Apache Kafka Java application that has both a producer and consumer.</li> <li>View consumer and producer message traffic in IBM Event Streams console.</li> <li>Specifying the topic within IBM Event Streams and then connecting an Apache Kafka application to produce and consume messages to and from that topic.</li> </ul>"},{"location":"getting-started/eepm/","title":"Event endpoint management","text":""},{"location":"getting-started/eepm/#about-this-lab","title":"About this Lab","text":"<p>In this lab, you will learn:</p> <ul> <li>The Application Developer capability to subscribe to topics easily from Event Endpoint Management (EEM).  </li> <li>Consume messages from topics via EEM </li> </ul> <p>The following diagram explains some the components involved in the lab and the global flow, an API developer will do and an Application developer will also performs.</p> <p></p> <p>This lab is NOT about API manager(Kafka topic owner in diagram above) creating asyncAPI for application developers to subscribe to. You will play the role of the App developer and mostly do the steps 5,6,8  and 9.</p> References: <ul> <li>Event Endpoint Management:  https://www.ibm.com/docs/en/cloud-paks/cp-integration/2022.2?topic=capabilities-event-endpoint-management-deployment</li> <li>Understanding AsyncAPI and Kafka topic article</li> <li>Dale Lane's blog</li> </ul>"},{"location":"getting-started/eepm/#lab-prerequisites","title":"Lab Prerequisites","text":"<ol> <li>Access to a API Connect Developer Portal  </li> <li>The KafkaClient used in the Schema Registry lab. </li> </ol>"},{"location":"getting-started/eepm/#lab-procedures","title":"Lab Procedures","text":"<ol> <li> <p>Open the Developer portal (link provided in table below) and register a login for yourself (if this is the first time you are logging in. You need a real email address and you can use one of the student userid). If you already have a username created, login to the portal. For users who are creating the login for the first time, you will receive an email for confirmation. </p> <p>Please use one of these URLs to access the Developer Portal, matching the userid you have:</p> Host URL Ventress Ventress API Portal Cody Cody API portal Finn Finn API portal <p></p> <p>then you should reach the portal main home page, with the <code>TechJam product defined</code></p> <p></p> <p></p> <p>This portal is coming from the Admin user, and he defined an API product defining AsyncAPI on a customers topic in the event streams running in the OpenShift cluster under <code>cp4i-eventstreams</code>.</p> </li> <li> <p>Create an App.</p> <p>Go to Apps and Click on \u201cCreate a new app\u201d.     Enter a name and click on save.</p> <p></p> <p>The API Key and secret will be provided. Take note of it and close the box.</p> <p>The new app has been created. You can optionally click on \u2018Verify\u2019 and enter the secret copied to ensure the credentials you copied are correct. </p> </li> <li> <p>Subscribe to the Product and get connectivity details.   </p> <p>In the main portal, Go to \"API Products\".   </p> <p>Look for a product and Click on it.</p> <p></p> <p>Take note of the connectivity details and click on \"Get Access\".  Refer to the steps in the image below. </p> <p>Take note of the following: </p> <pre><code>topic, bootstrap_server, client_id, sasl_mechanism and security_protocol. \n</code></pre> <p>These fields will be needed to establish connection to the EventStreams via EEM. </p> <p></p> <p></p> <p>Click on \u201cSelect\u201d.</p> <p>Click on the newly created app and proceed to complete the subscription process.</p> <p></p> <p>You have now subscribed to the AsyncAPI for the <code>customers</code> topic running in Event Streams within the same OpenShift cluster as the api management. </p> </li> <li> <p>Create the PEM certificate needed while accessing the EEM.</p> <p>Run this command from a terminal. </p> <pre><code>echo | openssl s_client -connect EVENT_GATEWAY_URL:PORT -servername EVENT_GATEWAY_URL\n</code></pre> <p>Example:</p> <pre><code>openssl s_client -connect apim-demo-myegw-event-gw-client-apic.apps.cody.coc-ibm.com:443 -servername apim-demo-myegw-event-gw-client-apic.apps.cody.coc-ibm.com\n</code></pre> <p>The EVENT_GATEWAY_URL is the server URL obtained in step 3. </p> <p>Copy the output lines between BEGIN CERTIFICATE and END CERTIFICATE to a file called eem_truststore.pem. The file should look like this:</p> <p></p> <p>Copy the file to <code>C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\</code></p> </li> <li> <p>Test consuming the data in the topic you have just subscribed using the KafkaClient that you used for the Schema Registry lab.</p> <ul> <li>Make a backup copy of the config.properties file in the following folder: <code>C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\</code></li> <li>Edit the config.properties file and make the following changes. </li> </ul> Field Value enableschemaavro false bootstrap.servers Enter the bootstrap_server URL obtained in step 3. sasl.jaas.config Paste this string. Replace the &lt;API_KEY&gt; and &lt;SECRET&gt; with the details you obtained in step 2. org.apache.kafka.common.security.plain.PlainLoginModule required username='&lt;API_KEY&gt;' password='&lt;SECRET&gt;'; sasl.mechanism PLAIN security.protocol SASL_SSL topic Name of the topic to consume (obtained in step 3) ssl.truststore.location Point it to the location of the PEM file eem_truststore.pem ssl.truststore.type PEM client.id Insert the client ID obtained from step 3. <p>The other fields can be left as it is. </p> <ul> <li>Now you can run the KafkaClient to consume data. </li> </ul> <pre><code>cd C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\ \njava -jar KafkaClient.jar consumer config.properties\n</code></pre> <p>You should see messages being consumed. </p> <p>Note</p> <p>EEM can only be used for consuming data. Not for producing data. </p> </li> </ol>"},{"location":"getting-started/mm2/","title":"Configuring and Running MirrorMaker 2 (MM2)","text":"<p>Rajan Krishnan,  IBM</p>"},{"location":"getting-started/mm2/#introduction","title":"Introduction","text":"<p>MirrorMaker2,  released  as  part  of  Kafka  2.4.0,  allows  you  to  mirror  multiple  clusters  and create many replication topologies. Learn all about this awesome new tool and how to reliably and easily mirror clusters.</p>"},{"location":"getting-started/mm2/#lab-objectives","title":"Lab Objectives","text":"<p>In  this  lab,  we  will  review  the  basic  concepts  of  MirrorMaker2.  You  will  demonstrate  the ability to migrate a topic from a source Kafka to a destination Kafka platform. You will ensure the migration was successful by checking the main properties of topics and consumers and comparing the source / destination Kafka clusters. </p>"},{"location":"getting-started/mm2/#pre-requisites","title":"Pre-Requisites","text":"<ul> <li>Working instance of Event Streams.</li> <li>A source Kafka cluster (e.g. Strimzi).</li> </ul>"},{"location":"getting-started/mm2/#understanding-mirrormaker-2-mm2","title":"Understanding MirrorMaker 2 (MM2)","text":"<p>MM2 addresses some of the problems with legacy MM (MM1).</p> <ul> <li>Offset translation \u2013avoid duplicates.</li> <li>Consumer group checkpoints.</li> <li>Topics con figurations synced (e.g. partitions, ACLs).</li> <li>MM2 takes advantage of the Kafka Connect ecosystem. </li> </ul> <p>MM2 has 3 main components / connectors.</p> <ol> <li> <p>MirrorSourceConnector</p> <ul> <li>Replicates remote topics, topic configurations.</li> <li>Emits Offset syncs2</li> </ul> </li> <li> <p>MirrorCheckPointConnector</p> <ul> <li>Consumes offset syncs.</li> <li>Combines offset syncs and consumer offset to emit checkpoint</li> </ul> </li> <li> <p>MirrorHeartBeatConnector</p> <ul> <li>Used for monitoring replication flows. </li> <li>Sends source heartbeats to remote. </li> </ul> </li> </ol> <p></p> <p>As part of the lab, we will deploy the Source Connectorand Checkpoint Connector</p>"},{"location":"getting-started/mm2/#lab-procedures","title":"Lab Procedures","text":"<p>In this lab, we will migrate data from an external Kafka topic to a local Kafka topic in Event Stream. The external Kafka can be Strimzi, Confluent, Opensource Kafka, another Event Stream platform or any other Kafka platform. For the purpose of this lab, we will use a Strimzi Kafka platform. </p> <p>When the lab steps are complete, the following details should be replicated between the source Kafka and destination Kafka:</p> <ul> <li>All the messages in the source kafka topic.</li> <li>Timestamp of messages should be preserved.</li> <li>The consumer groups and the respective lags. Message offset value will not be preserved due to retention policy in source kafka. </li> </ul>"},{"location":"getting-started/mm2/#1-take-note-of-source-kafka-topic-details","title":"1. Take note of source Kafka topic details.","text":"<p>You can check the status of strimzi topic here:</p> <p>https://kafdrop-rajan-strimzi.rajancluster-sng01-992844b4e64c83c3dbd5e7b5e2da5328-0000.jp-tok.containers.appdomain.cloud/topic/basicuserdata </p> <p>Take note of the topic name, consumer group, consumer lags and last offset message. </p> <p></p> <p></p>"},{"location":"getting-started/mm2/#2-take-note-of-your-kafkaconnect_url","title":"2. Take note of your KafkaConnect_URL.","text":"<p>Use one of the following KafkaConnect_URL depending on the Openshift Cluster that has been assigned to you</p> Host URL Ventress connect-cp4i-eventstreams.apps.ventress.coc-ibm.com Cody connect-cp4i-eventstreams.apps.cody.coc-ibm.com Finn connect-cp4i-eventstreams.apps.finn.coc-ibm.com"},{"location":"getting-started/mm2/#3-kafka-connect","title":"3. Kafka Connect","text":"<p>Check if Kafka Connect is already setup in the cluster and the MirrorMaker 2 plugins are available. </p> <p>Open a Command Terminal and enter this command. </p> <pre><code>curl -ki -X GET -H \"Accept: application/json\" https://&lt;KAFKACONNECT_URL&gt;/connector-plugins\n</code></pre> <p>Example:</p> <pre><code>curl -ki -X GET -H \"Accept: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connector-plugins/\n</code></pre> <p>You should get an output similar to this. </p> <p>Note</p> <p>You may use tools like jq to format the json output in an easy to read format. </p> <p>Ensure the MirrorMaker related plugins are listed. </p> <pre><code>[\n{\n\"class\": \"org.apache.kafka.connect.file.FileStreamSinkConnector\",\n\"type\": \"sink\",\n\"version\": \"3.1.1\"\n},\n{\n\"class\": \"org.apache.kafka.connect.file.FileStreamSourceConnector\",\n\"type\": \"source\",\n\"version\": \"3.1.0\"\n},\n{\n\"class\": \"org.apache.kafka.connect.mirror.MirrorCheckpointConnector\",\n\"type\": \"source\",\n\"version\": \"1\"\n},\n{\n\"class\": \"org.apache.kafka.connect.mirror.MirrorHeartbeatConnector\",\n\"type\": \"source\",\n\"version\": \"1\"\n},\n{\n\"class\": \"org.apache.kafka.connect.mirror.MirrorSourceConnector\",\n\"type\": \"source\",\n\"version\": \"1\"\n}\n]\n</code></pre>"},{"location":"getting-started/mm2/#4-mm2-connector-definitions","title":"4. MM2 Connector Definitions","text":"<ol> <li> <p>Download the MM2 connectors JSON file sample that will be used for creating connectors.</p> <pre><code>curl -X GET https://raw.githubusercontent.com/ibm-cloud-architecture/eda-tech-academy/main/tech-jam/mm2_json_files/mm2_source.json &gt; mm2_source.json\ncurl -X GET https://raw.githubusercontent.com/ibm-cloud-architecture/eda-tech-academy/main/tech-jam/mm2_json_files/mm2_checkpoint.json &gt; mm2_checkpoint.json\n</code></pre> <p>You will find 2 json files (<code>mm2_source.json &amp; mm2_checkpoint.json</code>). These 2 files will be used in the next steps. Copy the files to <code>C:\\TechJam\\EventStreams_Lab\\</code> Folder.</p> </li> <li> <p>Create the MM2 source connector JSON file. </p> <p>Edit the sample file <code>mm2_source.json</code> in the <code>C:\\TechJam\\EventStreams_Lab\\</code> Folder. Fill-in the details accordingly. </p> <p>Fields not mentioned in this table can be left to their default values. </p> parameter Value name Enter your studentID. Example: student60-source source.cluster.alias A name that you will give to the source cluster. All replicated topics will have a prefix of this alias.Make sure to use the studentID as the prefix. Example: student60-source target.cluster.alias A name that you will give to the target cluster. Make sure to use the studentID as the prefix. Example: student60-target source.cluster.bootstrap.servers Kafka Bootstrap URL of the source Strimzi cluster. You can use this. <code>rajancluster-sng01-992844b4e64c83c3dbd5e7b5e2da5328-0000.jp-tok.containers.appdomain.cloud:30719</code> target.cluster.bootstrap.servers Kafka Bootstrap URL of the target Event Stream Cluster. For the purpose of this lab, we have created a PLAIN connection. <code>es-demo-kafka-bootstrap.cp4i-eventstreams.svc:9092</code> topics Use the topic called \u201cbasicuserdata\u201d that has been created for the purpose of this lab. <p></p> <p>This is a sample of how the file should look like. </p> </li> </ol>"},{"location":"getting-started/mm2/#5-mm2-connector-deployment","title":"5. MM2 connector deployment","text":"<ol> <li> <p>Create a MM2 Source Connector.</p> <p>We will use REST API to create the connector. Open a command prompt. Type this command.</p> <pre><code>cd C:\\TechJam\\EventStreams_Lab\\\ncurl -ki -X POST -H \"Content-Type: application/json\" https://&lt;KAFKACONNECT_URL&gt;/connectors --data \"@./mm2_source.json\"\n# Example:\ncurl -ki -X POST -H \"Content-Type: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connectors --data \"@./mm2_source.json\"\n</code></pre> </li> <li> <p>Check the status of the MM2 connector. From the command prompt, type:</p> <pre><code># First Get the connector name from the output. \ncurl -ki -X GET -H \"Accept: application/json\" https://&lt;KAFKACONNECT_URL&gt;/connectors\n\n# Example:\ncurl -ki -X GET -H \"Accept: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connectors/\n\n[\"cody20\"]\n# Then, get the status of the connector.\ncurl -ki -X GET -H \"Accept: application/json\" https://&lt;KAFKACONNECT_URL&gt;/connectors/&lt;connector_name&gt;/status\n\n# Example:\ncurl -ki -X GET -H \"Accept: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connectors/cody20/status/\n\n{\n\"name\": \"cody20\",\n\"connector\": {\n\"state\": \"RUNNING\",\n    \"worker_id\": \"10.128.0.52:8083\"\n},\n\"tasks\": [\n{\n\"id\": 0,\n        \"state\": \"RUNNING\",\n        \"worker_id\": \"10.128.0.52:8083\"\n}\n],\n\"type\": \"source\"\n}\n</code></pre> </li> </ol>"},{"location":"getting-started/mm2/#6-verify-topic-creation","title":"6. Verify topic creation","text":"<ol> <li>Check the EventStreams web console and a new topic should have been created.  Look for the replicated topic. The topic should be named as: <code>&lt;SOURCE_CLUSTER_ALIAS&gt;-basicuserdata</code> Example: cody20-source.basicuserdata</li> </ol>"},{"location":"getting-started/mm2/#7-create-mm2-checkpoint","title":"7. Create MM2 Checkpoint","text":"<ol> <li> <p>Create the MM2 Checkpoint connector JSON file. </p> <p>Edit the sample file <code>mm2_checkpoint.json</code> in the <code>C:\\TechJam\\EventStreams_Lab\\</code> Folder. Fill-in the details accordingly.  Fields not mentioned in this table can be left to it\u2019s default values. </p> parameter Value name Enter your studentID-checkpoint. Example: cody20-checkpoint source.cluster.alias A name that you will give to the source cluster. All replicated topics will have a prefix of this alias.Make sure to use the studentID as the prefix. Example: cody20-source target.cluster.alias A name that you will give to the target cluster. Make sure to use the studentID as the prefix. Example: cody20-target source.cluster.bootstrap.servers Kafka Bootstrap URL of the source Strimzi cluster. <code>rajancluster-sng01-992844b4e64c83c3dbd5e7b5e2da5328-0000.jp-tok.containers.appdomain.cloud:30719</code> target.cluster.bootstrap.servers Kafka Bootstrap URL of the target Event Stream Cluster. For the purpose of this lab, we have created a PLAIN connection. <code>es-demo-kafka-bootstrap.cp4i-eventstreams.svc:9092</code> groups The consumer groups that has to be replicated. For the purpose of this lab we will replicate all groups in the source Kafka. So, use the value \u201c.*\u201d <p></p> <p>This is a sample of how the file should look like. </p> </li> <li> <p>Create a MM2 Checkpoint Connector.</p> <p>We will use REST API to create the connector. Open a command prompt. Type this command.</p> <pre><code>cd C:\\TechJam\\EventStreams_Lab\\\ncurl -ki -X POST -H \"Content-Type: application/json\" https://&lt;KAFKACONNECT_URL&gt;/connectors --data \"@./mm2_checkpoint.json\"\n# Example:\ncurl -ki -X POST -H \"Content-Type: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connectors --data \"@./mm2_checkpoint.json\"\n</code></pre> </li> <li> <p>Check the status of the MM2 Checkpoint connector. From the command prompt, type:</p> <p>First Get the connector name from the output. </p> <pre><code>curl -ki -X GET -H \"Accept: application/json\" &lt;KAFKACONNECT_URL&gt;/connectors\n\n# Example:\ncurl -ki -X GET -H \"Accept: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connectors/\n\n[\"cody20\",\"cody20-checkpoint\"]\n# Then, get the status of the checkpoint connector.\ncurl -ki -X GET -H \"Accept: application/json\" https://&lt;KAFKACONNECT_URL&gt;/&lt;connector_name&gt;/status\n\nExample:\ncurl -ki -X GET -H \"Accept: application/json\" https://connect-cp4i-eventstreams.apps.cody.coc-ibm.com/connectors/cody20-checkpoint/status/\n\n{\n\"name\": \"cody20-checkpoint\",\n\"connector\": {\n\"state\": \"RUNNING\",\n    \"worker_id\": \"10.128.0.52:8083\"\n},\n\"tasks\": [\n{\n\"id\": 0,\n        \"state\": \"RUNNING\",\n        \"worker_id\": \"10.128.0.52:8083\"\n}\n],\n\"type\": \"source\"\n}\n</code></pre> </li> </ol>"},{"location":"getting-started/mm2/#8-check-consumer-lag","title":"8. Check consumer Lag.","text":"<p>Check consumer lags in Event Streams. </p> <ul> <li>Go to Event Streams home page -&gt; Topics -&gt; Click on the replicated topic -&gt; Click on \u201cConsumer Groups\u201d.</li> </ul> <p>The new consumer group should appear and the offset lag should match with that of strimzi. </p> <p></p> <ul> <li>Do a random check on the timestamp of a message. </li> </ul> <p></p> <p>Now you can consume the data from the Event Streams cluster. You will only be consuming the remaining messages. </p> <p>Make a copy of the <code>config.properties</code> file.  Call it <code>config.properties.mm2</code> Edit the <code>config.properties.mm2</code>file and change the following fields.  You will have to create a new SCRAM user, and this time, at the point where you choose consumers, select \"All Consumers\".   </p> Field Value sasl.jaas.config Use the newly created SCRAM user and password enableschemaavro False topic The newly replicated topic. Example: student60-source.basicuserdata group.id You should use the same Consumer Group as the one that has been replicated.     general-strimzi-consumer-v1 <p>Run the KafkaClient in consumer mode:</p> <pre><code>java -jar KafkaClient.jar consumer config.properties.mm2\n</code></pre> <p>It should only consume the number of messages as listed in the lags (and not the entire message data in the topic). </p>"},{"location":"getting-started/schema-lab/","title":"Producing &amp; Consuming Data with Event Streams and Schema","text":""},{"location":"getting-started/schema-lab/#introduction","title":"Introduction","text":"<p>Version control can be a nightmare for organizations. With Kafka, it\u2019s no different. With stream processing pipelines, there are no files to act as containers for messages with a single format. Let take a look at how Event Streams handles Schema Management with the Schema Registry.</p>"},{"location":"getting-started/schema-lab/#lab-objective","title":"Lab Objective","text":"<p>In this lab, we\u2019ll do the following: </p> <ul> <li>Create a topic and attach a schema to it</li> <li>Create a Kafka User with appropriate rights to produce and consume data</li> <li>Gather information needed to connect to the Kafka cluster and Schema registry.</li> <li>Test producing / consuming data.</li> <li>Make changes to the Schema and see the impact to producer/consumer.</li> </ul> <p>The following figure illustrates the components involved in this lab:</p> <p></p> <p>You will run producer and consumer apps on your laptop, and they will contact schema registry and brokers using SCRAM authentication and TLS encryption.</p>"},{"location":"getting-started/schema-lab/#setting-up-the-client-machine","title":"Setting Up The Client Machine","text":"<p>Setting up the sample Kafka Client to be used for the lab.</p> <p>This section provides the instructions for setting up the Kafka Client that will be used throughout the labs.</p> <ol> <li> <p>Check java install</p> <p></p> <pre><code>C:\\Users\\rajan&gt;java -version\nAt least version 17.0 should be available.\n</code></pre> <p>If it\u2019s not installed, download and install the Java Runtime. Use the adoptium site to download Java</p> </li> <li> <p>Download the sample Kafka Client code from here: to be used on your local laptop.</p> </li> <li> <p>Unzip the downloaded Kafka Client (KafkaClient_YYYYMMDD.zip) into a folder: </p> <pre><code>C:\\TechJam\\EventStreams_Lab\\\nunzip KafkaClient_20240203.zip </code></pre> </li> <li> <p>Test the client: Open a Command Prompt.</p> <pre><code>cd C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\\njava -jar KafkaClient.jar\n</code></pre> </li> </ol> <p></p>"},{"location":"getting-started/schema-lab/#pre-requisites","title":"Pre-Requisites","text":"<ul> <li>Have setup the client machine properly. </li> <li>Able to access the Event Streams web interface. </li> </ul>"},{"location":"getting-started/schema-lab/#understanding-schema-registry","title":"Understanding Schema Registry","text":""},{"location":"getting-started/schema-lab/#what-is-a-schema-registry","title":"What is a Schema Registry?","text":"<p>Schema Registry provides a serving layer for your metadata. It provides a RESTful interface for storing and retrieving your Avro\u00ae, JSON Schema, and Protobuf schemas. </p> <ul> <li>It stores a versioned history of all schemas based on a specified subject name strategy, provides multiple compatibility settings.</li> <li>Allows evolution of schemas according to the configured compatibility settings and expanded support for these schema types. </li> <li>Provides serializers that plug into Apache Kafka\u00ae clients that handle schema storage and retrieval for Kafka messages that are sent in any of the supported formats.</li> </ul> <p>In Event Streams, Schemas are stored in internal Kafka topics by the Apicur.io Registry, an open-source schema registry led by Red Hat. In addition to storing a versioned history of schemas, Apicurio Registry provides an interface for retrieving them. Each Event Streams cluster has its own instance of Apicurio Registry providing schema registry functionality.</p> <p></p>"},{"location":"getting-started/schema-lab/#how-the-schema-registry-works","title":"How the Schema Registry Works?","text":"<p>Now, let\u2019s take a look at how the Schema Registry works.</p> <ol> <li>Sending applications request schema from the Schema Registry.</li> <li>The scheme is used to automatically validates and serializes be for the data is sent.</li> <li>Data is sent, serializing makes transmission more efficient. </li> <li>The receiving application receives the serialized data.</li> <li>Receiving application request the schema from the Schema Registry. </li> <li>Receiving application deserializes the same data automatically as it receives the message.  </li> </ol> <p></p>"},{"location":"getting-started/schema-lab/#lab-procedures","title":"Lab Procedures","text":""},{"location":"getting-started/schema-lab/#creating-a-topic-and-attaching-a-schema-to-it","title":"Creating a topic and attaching a schema to it","text":"<ol> <li> <p>Click on one of the links below (depending on the OpenShift cluster allocated to you) to log into your Event Streams instance using the student credentials provided. Once you've logged in, you'll see the Event Streams homepage.</p> Host URL Finn https://cpd-cp4i.apps.finn.coc-ibm.com/integration/kafka-clusters/cp4i-eventstreams/es-demo/gettingstarted Cody https://cpd-cp4i.apps.cody.coc-ibm.com/integration/kafka-clusters/cp4i-eventstreams/es-demo/gettingstarted Ventress https://cpd-cp4i.apps.ventress.coc-ibm.com/integration/kafka-clusters/cp4i-eventstreams/es-demo/gettingstarted <p></p> </li> <li> <p>Create Topic.</p> <p>Click on Create a Topic. Use only lower cases for the topic name (e.g. <code>finn20-customers</code>).</p> <p></p> <p>Please refer to screenshots attached as sample. </p> <p></p> </li> <li> <p>Next create the schema and attach to the topic. </p> <ul> <li>Click on the Schema Registry tab in the left. </li> </ul> <p></p> <ul> <li>Click on Add Schema (in the right)</li> </ul> </li> </ol> <p></p> <ul> <li> <p>Click Upload Definition -&gt; Choose <code>customer.avsc</code> located in the Kafka Client unzipped folder. (<code>C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\</code>)</p> <p></p> <ul> <li>Check the details and make sure the schema is valid. </li> <li>Change the name of the schema to avoid conflict with other students: The name of the schema maps the schema to the topic. To attach this schema to your topic, the schema should be named according to the topic: -value. (For example, if your topic is <code>finn20-customers</code>\u201d, the schema should be named) <p></p> <p>Click on Add Schema. The schema is now attached to the topic. </p>"},{"location":"getting-started/schema-lab/#creating-a-kafka-user-with-appropriate-rights","title":"Creating a Kafka User with appropriate rights.","text":"<ol> <li> <p>Go to the Event Streams home page. Select \u201cConnect to this Cluster\u201d -&gt; Generate SCRAM Credentials.</p> <p></p> </li> </ol> <p></p> <pre><code>Refer to the screenshot attached as reference.\n</code></pre> <p></p> <pre><code>Keep information about the SCRAM password.\n</code></pre>"},{"location":"getting-started/schema-lab/#gather-connection-details","title":"Gather Connection Details","text":"<p>Creating connection from Consumer / Producer requires some connectivity details. These details can be gathered from the Event Stream\u2019s portal. Connectivity details needed will depend on type of authentication and SASL mechanism used. </p> <p>From the Event Stream home page, click on \u201cConnect to this Cluster\u201d.  Get the following information from the page. Refer to screenshot below on how to get these.</p> <ol> <li>Bootstrap URL</li> <li>Truststore Certificate File. Copy the downloaded file to the Kafka Client folder.</li> <li>Truststore Password. (Password will be generated once Download Certificate is clicked).</li> <li>Schema Registry URL</li> </ol> <p></p>"},{"location":"getting-started/schema-lab/#test-producer-consumer","title":"Test Producer / Consumer","text":"<ol> <li> <p>Prepare the <code>config.properties</code> file located in <code>C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\</code> Check and change the following fields. The fields not mentioned here can be left default. </p> Field Value enableschemaavro True (as we have schema attached to the topic) bootstrap.servers Enter the URL obtained in previous section e.g. es1-kafka-bootstrap-cp4i.apps.ocp46.tec.uk.ibm.com:443 sasl.jaas.config Paste this string. Replace the Username and Password.  org.apache.kafka.common.security.scram.ScramLoginModule required username='' password=''; sasl.mechanism SCRAM-SHA-512 security.protocol SASL_SSL topic Topic created previously. E.g. jam60-topic1 group.id Enter a Consumer Group ID. You can enter a Consumer Group. Remember that it should have a prefix of your studentID. E.g. jam60-consumer-group-v1 ssl.truststore.location Should point to the Truststore certificate downloaded. Example:  ./es-cert.p12 ssl.truststore.password Enter the Truststore password obtained. apicurio.registry.url Enter the URL obtained in previous section e.g. https://es1-ibm-es-ac-reg-external-cp4i.apps.ocp46.tec.uk.ibm.com schema.registry.basic.auth.user \\&lt;SCRAM_USER&gt; schema.registry.basic.auth.password \\&lt;SCRAM_PASSWORD&gt; schema.registry.ssl.truststore.location Same as ssl.truststore.location schema.registry.ssl.truststore.password Same as ssl.truststore.password <p>This is how your <code>config.properties</code> should look like after the changes. This is a sample. Do not copy and paste this contents. </p> <pre><code>## Mandatory Section ##\n# Set to true if avro schema is enabled for the topic\nenableschemaavro = true\n# Set to true if want to enable Intercept Monitoring.\nenableintercept = false\n# Set this to true if mTLS (2-way TLS authentication) is enabled.\nenablemtls = false\n# Broker related properties\nbootstrap.servers = es-demo-kafka-bootstrap-cp4i-eventstreams.apps.cody.coc-ibm.com:443\nsasl.jaas.config = org.apache.kafka.common.security.scram.ScramLoginModule required username='cody200-sr-user' password='EelwRR1';\n# Example: sasl.jaas.config = org.apache.kafka.common.security.scram.ScramLoginModule required username='student01' password='B9BmjHvJZC';\n# Options are PLAIN, SCRAM-SHA-512, GSSAPI\nsasl.mechanism=SCRAM-SHA-512\n# Options are SSL, PLAINTEXT, SASL_SSL, SASL_PLAINTEXT\nsecurity.protocol=SASL_SSL\ntopic=cody200-sr\n# Consumer Group ID\ngroup.id = cody200-group1\n# Example: group.id = student01-group\nclient.id=302071b2-7daf-4844\n#--------------------------------\n## To be filled in if TLS is enabled for the Brokers\n# Options are PKCS12, JKS, PEM. Password not required for PEM.\nssl.truststore.type=PKCS12\nssl.truststore.location=./es-cert.p12\nssl.truststore.password=luONbNsf\n#--------------------------------\n## To be filled if mTLS (Mutual TLS) is enabled in Brokers\nssl.keystore.location=/home/rajan/load_security/kafka.client.keystore.jks\nssl.keystore.password=clientpass\nssl.key.password=clientpass\n#-------------------------------\n## To be filled in if Schema is enabled\napicurio.registry.url = https://es-demo-ibm-es-ac-reg-external-cp4i-eventstreams.apps.cody.coc-ibm.com\n# To be set to true if schema is not created up front.\nauto.register.schemas=false\n## To be filled in if Schema Registry requires Authentication.\nbasic.auth.credentials.source = USER_INFO\nschema.registry.basic.auth.user = cody200-sr-user\nschema.registry.basic.auth.password = EelwRR1\n#--------------------------------\n## To be filled in if TLS is enabled for Schema Registry\nschema.registry.ssl.truststore.type=PKCS12\nschema.registry.ssl.truststore.location=./es-cert.p12\nschema.registry.ssl.truststore.password=luNbNsf\n#--------------------------------\n## To be filled if Consumer / Producer Intercept should be turned on\nintercept_bootstrapServers = es3minimal-kafka-bootstrap-es3.mycluster-rajan07-992844b4e64c83c3dbd5e7b5e2da5328-0000.jp-tok.containers.appdomain.cloud:443\nintercept_sasljaas = org.apache.kafka.common.security.scram.ScramLoginModule required username='rajan' password='CfKQZG9Cm7g5';\nintercept_security = SASL_SSL\nintercept_saslmechanism = SCRAM-SHA-512\n#--------------------------------\n## To be used when Kerberos Authentication is used\nsasl.kerberos.service.name=kafka\n#--------------------------------\n## Other Optional parameters.\nretries = 2\n</code></pre> <li> <p>Test producing message. </p> <p>Go to this folder in command prompt:</p> <pre><code>cd C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\ \njava -jar KafkaClient.jar producer 10 config.properties\n</code></pre> <p>Check if the message is listed in the topic. In the Event Streams portal, go to Topics. Look for the topic that you created. Click on it. Then click on messages.  You should see the messages produced. </p> <p>Warning</p> <p>The messages content may not be displayed correctly in the portal due to binary serialization with Avro.</p> <p></p> </li> <li> <p>Test consuming message. </p> <pre><code>java -jar KafkaClient.jar consumer config.properties\n</code></pre> <p>Messages should be consumed correctly.  Message content should be displayed correctly. Press CTRL-C to stop the consumer. </p> <p></p> </li>"},{"location":"getting-started/schema-lab/#check-the-impact-of-changing-the-schema-registry","title":"Check the impact of changing the Schema Registry","text":"<ol> <li> <p>We will change the schema registry by adding a new field with default value, and check what happens when producing / consuming. </p> <p>In the client computer, make a copy of the customer.avsc file (located in <code>C:\\TechJam\\EventStreams_Lab\\KafkaClient_YYYYMMDD\\&gt;</code>) and name it <code>customer_v2.avsc</code>. You can do this from Windows Explorer.</p> <p>Edit the file using Notepad++. Add this line right after country. Change the version to version <code>1.1</code>.</p> <pre><code>   { \"name\": \"company\", \"type\": \"string\", \"doc\": \"Customer Company\"},\n</code></pre> <p>The <code>customer_v2.avsc</code> should look like this:</p> <p></p> <p></p> </li> <li> <p>From the Event Streams portal, Go to Schema Registry -&gt; Click on your Schema. Then, click on \u201cAdd New Version\u201d.</p> </li> <li> <p>Click on \u201cUpload Definition\u201d and select the edited avsc file (<code>customer_v2.avsc</code>).</p> <p></p> <p>You should get a validation failed message. </p> </li> <li> <p>Understanding Schema Registry Evolution</p> <p>When a schema is created, it has to have a compatibility mode. The most used compatibility modes are:</p> <ul> <li>BACKWARD - new schema can be used to read data written with old schema [e.g. consumer uses the new schema and read an older offset data]</li> <li>FORWARD - old schema can still be used (e.g. by consumers) to read data written in new schema</li> <li>FULL - Both forward and backward</li> </ul> <p>In Event Streams, the default compatibility mode is FULL. </p> <p>In our <code>customer_v2.avsc</code> we have added a new mandatory field. Older consumers may not be aware of this field until they update their code. Hence, our schema is NOT FORWARD compatible and so, it fails validation. </p> </li> <li> <p>Now, edit the schema file (customer_v2.avsc) again and add a default value to the newly added line. The line should look like this:</p> <pre><code>{ \"name\": \"company\", \"type\": \"string\", \"default\": \"IBM\", \"doc\": \"Customer Company\" },\n</code></pre> <p>The <code>customer_v2.avsc</code> should look like this.</p> <p></p> </li> <li> <p>Now try updating the schema. Validation should pass. Change the version number and click on \u201cAdd Schema\u201d. </p> </li> <li> <p>Test producing / consuming data</p> </li> <li> <p>Getting details about the schema. </p> <p>The Event Streams schema registry supports a Rest Endpoint that provides details about the schema. </p> <p>First make sure you have the Basic Authentication Token created during the process of creating the Kafka SCRAM User. If you missed copying the token, you can generate the token from the SCRAM USERNAME and SCRAM PASSWORD. </p> <p>Open this URL: https://www.base64encode.org/ Enter your SCRAM USERNAME and SCRAM PASSWORD separated by a colon. E.g. : Click on Encode and it will generate the Basic Authentication Token.  <p>Get the default compatibility. </p> <pre><code>curl -ki -X GET -H \"Accept: application/json\" -H \"Authorization: Basic &lt;BASIC AUTH TOKEN&gt;\" https://&lt;SCHEMA_REGISTRY_URL&gt;/rules/COMPATIBILITY\nE.g. curl -ki -X GET -H \"Accept: application/json\" -H \"Authorization: Basic &lt;BASIC_AUTH_TOKEN&gt;\" https://es1-ibm-es-ac-reg-external-cp4i.apps.ocp46.tec.uk.ibm.com/rules/COMPATIBILITY\n</code></pre> <p>The response should be something like:</p> <pre><code>{\"config\":\"FULL\",\"type\":\"COMPATIBILITY\"}\n</code></pre> <p>This shows that the default compatibility is FULL.</p> <p>Next get the compatibility of the specific schema that we are using. </p> <pre><code>curl -ki -X GET -H \"Accept: application/json\" -H \"Authorization: Basic &lt;BASIC_AUTH_TOKEN&gt;\" https://es1-ibm-es-ac-reg-external-cp4i.apps.ocp46.tec.uk.ibm.com/artifacts/&lt;YOUR_SCHEMA_NAME&gt;/rules\n</code></pre> <p>This should give you an empty response </p> <pre><code>[]\n</code></pre> <p>Which basically means \u2013 the schema uses the default global setting \u2013 which is FULL (as we saw when we tried changing the schema).</p> <ul> <li>Test sending some message, you will see default value for the company new field.</li> </ul> <pre><code>java -jar KafkaClient.jar producer 10 config.properties\n</code></pre> <p>!!! success \"Congratulations!\" You've completed the schema registry lab. </p> <p>&gt;&gt; Next - Event End Point Management</p>"},{"location":"lab1/","title":"Real-time inventory solution design","text":"<p>This use case is coming from four customer's engagements since the last three years. </p> <p>Duration: 30 minutes</p>"},{"location":"lab1/#pre-requisites-mac-users","title":"Pre-requisites - MAC Users","text":"<ul> <li>Have a git client installed</li> <li>Have a git account into IBM Internal github or public github.</li> <li>A JDK 11.</li> <li> <p>Install the make tool:</p> <ul> <li><code>brew install make</code></li> </ul> </li> <li> <p>Have oc cli installed. It can be done once connected to the OpenShift cluster using the &lt;?&gt; icon on the top-right and \"Command Line Tool\" menu.     </p> </li> <li> <p>Get a Java development IDE, we use Visual Code in our group.</p> </li> <li>Install Java Coding Pack for Visual Studio. This will download JDK and the necessary plugins.</li> <li> <p>OCP access with CP4I installed, could be ROKS, TechZone with CP4I cluster, we are using CoC environment as a base for our deployments See environment section for your assigned cluster</p> </li> <li> <p>To access to the git repository click on the top right icon from the documentation page:</p> </li> </ul> <p></p> <p>ibm-cloud-architecture/eda-tech-academy</p> <p>Fork this repository to your own git account so you can modify content and deploy code from your repository when using GitOps.</p> <p></p> <p>and then clone it to your local laptop:</p> <pre><code>git clone https://github.com/ibm-cloud-architecture/eda-tech-academy/\n</code></pre>"},{"location":"lab1/#environments","title":"Environments","text":"<p>We have two OpenShift clusters available with 25 userids each.</p> <ul> <li>Finn cluster is console-openshift-console.apps.finn.coc-ibm.com</li> <li> <p>Cody cluster is console-openshift-console.apps.cody.coc-ibm.com</p> </li> <li> <p>Userids will be finn1 to finn25 for Finn cluster</p> </li> <li>Userids will be cody1 to cody25 for the Cody cluster. </li> </ul>"},{"location":"lab1/#scripts","title":"Scripts","text":"<p>All the scripts and configurations were developed from a Mac so no problem for you.</p>"},{"location":"lab1/#pre-requisites-windows-users","title":"Pre-requisites - Windows Users","text":"<ul> <li>Have a git client installed</li> <li>Have a git account into IBM Internal github or public github.</li> <li>Clone  https://github.com/ibm-cloud-architecture/eda-tech-academy/ repositary:    In GitHub Desktop, Choose to clone a URL. Enter the above URL.     Clone to a local folder (e.g. C:\\GitHub).   Ensure the C:\\Github folder and sub folders do not have the \u2018Read Only\u2019 turned on.    </li> <li>Install Visual Code.  https://code.visualstudio.com/ .   Ignore the warning about installing as an Admin user and continue.     In the \u2018Additional Tasks\u2019 screen, pick all the tasks.    </li> <li>Install Java Coding Pack for Visual Studio.  https://aka.ms/vscode-java-installer-win .   This will download JDK and the necessary plugins.    </li> <li> <p>Setup Windows Subsystem For Linux.  </p> <pre><code>Enable WSL.  \nOpen a PowerShell screen and run this command.   \nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux.  \nThis step will require a Reboot of the machine. Proceed to reboot.\n\nEnable Virtual Machine Feature    \ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart.  \n[May require restart for Windows 11]\n\nDownload and install the Linux kernel update package.  \n[https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi]\n\nIf you are in a Windows 11 environment, you may have to set the default WSL version to 1.   \nwsl --set-default-version 1.\n\nDownload and install Ubuntu Linux distribution from Microsoft Store.  \nhttps://aka.ms/wslstore    \nSearch for Ubuntu and click on \u2018Get\u2019.    \nThis will download and install Ubuntu terminal environment with WSL.    \nOnce installed Click on \u2018Open\u2019.   The first time, it will take some time to decompress some files.   \nWait for this step to complete.    \nAt the end, you\u2019ll be asked to create a username and password to be used to login. \nFinally, you will be in the Linux shell prompt.\n\nSubsequently, open a CMD (or PowerShell) terminal and enter \u2018bash\u2019 to get access to the Linux shell.\n</code></pre> </li> <li> <p>Setup a few tools in the Ubuntu system. Run these commands in the Ubuntu Shell screen.   </p> <pre><code>Install dos2unix.   \nsudo apt-get update.  \nsudo apt-get install dos2unix.\n\nInstall 'oc' CLI.\nwget https://downloads-openshift-console.apps.cody.coc-ibm.com/amd64/linux/oc.tar --no-check-certificate.  \ntar -xvf oc.tar.  \nsudo mv oc /usr/local/bin.\n\nInstall 'make'\nsudo apt install make.\n\nInstall 'zsh' shell.  \nsudo apt install zsh.\n</code></pre> </li> <li> <p>OCP access with CP4I installed, could be ROKS, TechZone with CP4I cluster, we are using CoC environment as a base for our deployments See environment section for your assigned cluster</p> </li> <li> <p>To access to the git repository click on the top right icon from the documentation page:</p> </li> </ul> <p></p> <p>ibm-cloud-architecture/eda-tech-academy</p> <p>Fork this repository to your own git account so you can modify content and deploy code from your repository when using GitOps.</p> <p></p> <p>and then clone it to your local laptop:</p> <pre><code>git clone https://github.com/ibm-cloud-architecture/eda-tech-academy/\n</code></pre>"},{"location":"lab1/#environments_1","title":"Environments","text":"<p>We have two OpenShift clusters available with 25 userids each.</p> <ul> <li>Finn cluster is console-openshift-console.apps.finn.coc-ibm.com</li> <li> <p>Cody cluster is console-openshift-console.apps.cody.coc-ibm.com</p> </li> <li> <p>Userids will be finn1 to finn25 for Finn cluster</p> </li> <li>Userids will be cody1 to cody25 for the Cody cluster. </li> </ul>"},{"location":"lab1/#problem-statement","title":"Problem statement","text":"<p>Today, a lot of companies which are managing item / product inventory are facing real challenges to get a close to real-time view of item availability and global inventory view. The solution can be very complex to implement while integrating Enterprise Resource Planning products and other custom legacy systems.</p> <p>Acme customer is asking you to present how to address this problem using an event-driven architecture  and cloud native microservices. </p> <p>Normally to do MVP, we propose to use an Event Storming workshop to discover the problem statment, the stakeholders, the business goals, and the business process from an event point of view.  The image below is an example of the outcomes of such event storming session.  </p> <p></p> <p>A MVP will be complex to implement, but the customer wants first to select a technology, so a proof of concept needs to be done to guide them on how our product portfolio will address their problems.</p> <p>How to start?</p>"},{"location":"lab1/#exercise-1-system-design","title":"Exercise 1: system design","text":"<p>Giving the problem statement:</p> <p>How to design a near real-time inventory view of Stores, warehouses, scaling at millions of transactions per minutes?</p> <p>how do you design a solution, that can get visibility of the transactions, at scale, and give a near-real time consistent view of the items in store, cross stores and what do you propose to the customer as a proof of concept.</p> <p>Start from a white page, design components that you think will be relevant.</p> <p>Duration: 30 minutes</p> <p>Expected outcome</p> <ul> <li>A diagram illustrating the design. If you use Visual Code you can get the drawio plugin</li> <li>A list of questions you would like to see addressed</li> </ul>"},{"location":"lab1/#some-information-you-gathered-from-your-framing-meeting","title":"Some information you gathered from your framing meeting","text":"<ul> <li>SAP is used to be the final system of record</li> <li>Company has multiple stores and warehouses</li> <li>Sale and restock transactions are in a TLOG format</li> <li>Stores and warehouses have local view of their own inventory on local servers and cash machines. </li> <li>Some inventory for warehouses and transactions are done in mainframe and shared with IBM MQ</li> <li>Item has code bar and SKU so people moving stock internally can scan item so local system may have visibility of where items are after some small latency.</li> <li>The volume of transactions is around 5 millions a day</li> <li>Deployment will be between 3 data centers to cover the territory the company work in.</li> <li>Customer has heard about kafka, but they use MQ today, CICS, Java EE applications on WebSphere</li> <li>Architect wants to deploy to the cloud and adopt flexible microservice architecture</li> <li>SAP system will stay in enterprise</li> <li>Architect wants to use data lake solution to let data scientists develop statistical and AI  models.</li> </ul> Guidances <ul> <li>Think about enterprise network, cloud providers, stores and warehouses as sources.</li> <li>SAP - Hana is one of the system of record and will get data from it</li> <li>It is also possible to get data before it reaches SAP</li> <li>SAP has database tables that can be used as source of events</li> <li>As warehouse systems are using MQ, queue replication is something to think about</li> </ul> What could be a PoC scope? <ul> <li>You may want to demonstrate Event Streams capabilities as Kafka backbone</li> <li>You want to demonstrate MQ source connector to get message from MQ to Kafka</li> <li>You may want to explain how messages are published from a microservice using Microprofile Reactive Messaging</li> <li>The real-time aggregation to compute store inventory can be done with streaming processing, and Kafka Streams APIs can be used for that.</li> <li>For Data lake integration, you can illustrates messages landing in S3 buckets in IBM Cloud Object Storage using Kafka Sink connector. </li> </ul> <p>See the Solution</p>"},{"location":"lab1/lab1-sol/","title":"Real-time inventory system design proposal","text":"<p>The system design of this proof of concept should be simple, but not the global solution, and in the presale work we have to pitch a higher view of what the solution may look like so customer's feels confortable about how your proof of concept solution will fit in a bigger solution.</p>"},{"location":"lab1/lab1-sol/#global-solution-view-of-real-time-inventory","title":"Global solution view of real-time inventory","text":"<p>The core principle, is that each components responsible of managing some inventory elements will push events about their own inventory updates to a central data hub, that will be used to update back ends, ERP, systems.</p> <p>This central event backbone also exposes data so it will be easy to plug and play streaming processing for computing different statistical aggregates.</p> <p>The following figure is such high level business view of what a solution looks like</p> <p></p> <p>Servers in the stores and warehouses  (Store Server and Warehouse Server ) are sending sale transactions or item restock messages to a central messaging platform, where streaming components (the green components) are computing the different aggregates and are publishing those aggregation results to other topics. </p> <p>The architecture decision is to adopt loosely coupling component, asynchronous communication, being able to scale horizontally and be resilient. A pub/sub model is used, where components can start consuming messages long time after they were published, or immediately after.</p> <p>The system design is based on the lambda architecture, a classical data streaming pipeline architecture, as presented in IBM EDA reference architecture:</p> <p></p> <p>Streaming applications work as consuming events, processing them and producing new events in different topic. Those applications will guaranty exaclty once delivery, so it will help for inventory consistency.</p> <p>IBM MQ and IBM Event Streams are used to support a shared message as a services architecture where any asynchronous communication between applications is supported.</p> <p>We want to use MQ to get messages from mainframe applications or  MDB JEE apps. MQ Streaming Queue or queue to queue replication will help moving those messages to the OpenShift cluster. </p> <p>MQ Source kafka connector will be used to inject to Event Streams topic. A <code>items</code> topic will be used to receive transactions about items as a restock or sale events.</p> <p>Sink connectors, based on Kafka Connect framework, may be used to move data to long persistence storage like s3 bucket, datalake, Database,... or to integrate back to Legacy ERP systems.</p> <p>The Enterprise Network column includes the potential applications the data pipeline is integrated with.</p> More information <ul> <li>If you want to reuse the diagram the source is at this url</li> <li>EDA reference architecture presentation and argumentations</li> <li>Kappa architecture</li> </ul>"},{"location":"lab1/lab1-sol/#demos-proof-of-concept-view","title":"Demos / proof of concept view","text":"<p>Now that you have positionned a high level view, for the proof of concept, you want to leverage the cloud pak for integration packaging, and use at least MQ, Kafka Connector, Event Streams, streaming application, and a sink to cloud object storage or AWS S3.</p> <p>You want to demonstrate MQ as a source for message coming from warehouses. Those messages are sent to Event Streams topic via kafka connector.</p> <p>You may need to simulate store or warehouse events and you can use simple json files for that and the kafka-console-producer.sh shell you can get from any Kafka deployment. You can also leverage the Store Simulator asset that can send messages to MQ, Kafka or RabbitMQ, random messages, or controlled scenario. This is what we will use in lab 3.</p> <p>You will deploy a kafka connector cluster with MQ source connector and different sink connector like elastic search or cloud object storage bucket.</p> <p>The following figure illustrates what a proof of concept may look like. Obviously you can reuse IBM demo for that:</p> <p></p> <p>Next lab will teach you how to develop the <code>store inventory</code> with Kafka Streams to compute item inventory cross stores.</p> More information <ul> <li>The store simulator application is a Reactive Messaging Java app, which generates item sales to different possible messaging middlewares ( RabbitMQ, MQ or directly to Kafka). The code of this application is in this https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator. If you want to browse the code, the main readme of this project includes how to package and run this app with docker compose, and explains how the code works. The docker image is quay.io/ibmcase/eda-store-simulator/</li> <li>The item inventory aggregator is a Kafka Stream application, done with Kafka Stream API. The source code is in the refarch-eda-item-inventory project. Consider this more as a black box in the context of the scenario, it consumes items events, aggregate them, expose APIs on top of Kafka Streams interactive queries and publish inventory events on <code>item.inventory</code> topic. </li> <li>The store inventory aggregator is a Kafka Stream application, done with Kafka Stream API. The source code is in the refarch-eda-store-inventory project the output is in <code>store.inventory</code> topic. </li> </ul>"},{"location":"lab2/","title":"Lab 2: Store inventory with Kafka Streams","text":"<p>In this Lab, you will learn simple Kafka Streams exercises using Java APIs, and then finish by implementing on of the proof of concept component to compute the store inventory for each items sold.</p>"},{"location":"lab2/#pre-requisites","title":"Pre-requisites","text":"<p>This lab requires some java experience.  Be sure to have completed the pre-requisites listed here</p> <ul> <li>Be sure your IDE, like VScode has java extension. For VSCode you can use Red Hat java extension</li> <li>maven is used to package and run some test. The project has <code>./mvnw</code> command that brings maven in the project.</li> <li>Open Visual Code. Click on \u201cOpen Java Project\u201d and pick the refarch-eda-store-inventory from the <code>eda-tech-academy\\lab2\\</code> folder </li> </ul> <p>From there, select / modify the java code and run it from Visual Code.</p>"},{"location":"lab2/#context","title":"Context","text":"<p>The figure illustrates what you need to build, the green rectangle, which is a Java application using Kafka Streams API consuming <code>items</code> events and computing <code>store inventory</code> events by aggregating at the store level.</p> <p></p> <p>In fact, most of the code is already done for you, and the lab is to help you building event streaming knowledge by increment. At the end of this training you should be able to reuse this approach in your future work. All the development is done by running on your local computer, not need to deploy to OpenShift.</p> <p>In the global view of the real-time inventory solution presented in the lab 1, the goal is to do the store aggregation processing.</p>"},{"location":"lab2/#step-by-step-exercises","title":"Step by step exercises","text":"<p>Before implementing the store inventory, you need to learn Kafka streams programming with a set of simple exercises. </p> <p>Review the  Kafka Streams API concepts and basic APIs here.</p> <p>To do the hands-on exerices, go to the <code>/lab2/refarch-eda-store-inventory</code> folder of this repository, load this folder into your IDE. Be sure you can run tests inside the IDE, it may be easier to debug.</p> <p></p>"},{"location":"lab2/#exercise-1-test-your-first-topology","title":"Exercise 1: Test your first topology","text":"<p>Duration: 10 minutes</p> <p>Goal: Test a basic topology inside unit test.</p> <p>In your IDE go to the <code>src/test/java/ut</code> folder and open the class: TestYourFirstTopology.java. The most important elements of this test are:</p> <ul> <li>The <code>TopologyTestDriver</code> is a class to test a Kafka Streams topology without Kafka. It uses dummy configuration.</li> <li>the <code>TestInputTopic</code> class is used to pipe test records to a topic in TopologyTestDriver. This is used to send test messages. The creation of this instance needs to specify the serializer or deserialer used.</li> <li>The <code>@BeforeAll</code> annotation on the <code>setup()</code> method means that it will be run before any test is executed, while the <code>@AfterAll</code> annotation on the teardown method ensures that it will be run after last test execution.  We use this approach to define the topology under test in this class.</li> </ul> Build test driver and topics<pre><code>import org.apache.kafka.streams.StreamsConfig;\nimport org.apache.kafka.streams.TestInputTopic;\nimport org.apache.kafka.streams.TestOutputTopic;\nimport org.apache.kafka.streams.TopologyTestDriver;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\n//...\nTopology topology = buildTopologyFlow();\ntestDriver = new TopologyTestDriver(topology, getStreamsConfig());\ninTopic = testDriver.createInputTopic(inTopicName, new StringSerializer(), new StringSerializer());\noutTopic = testDriver.createOutputTopic(outTopicName, new StringDeserializer(), new StringDeserializer()); </code></pre> <ul> <li>The <code>buildTopology</code> method utilizes the <code>StreamsBuilder</code> class to construct a simple Kafka Streams topology, reading from the input Kafka topic defined by the inTopicName String. The logic is simply to print the message, the filter on a <code>blue</code> value, and generates the output to a topic:</li> </ul> buildTopology(): Filter text message topology<pre><code>KStream&lt;String, String&gt; basicColors = builder.stream(inTopicName,Consumed.with(Serdes.String(), Serdes.String()));\nbasicColors.peek((key, value) -&gt; System.out.println(\"PRE-FILTER: key=\" + key + \", value=\" + value)) // (1)\n.filter((key, value) -&gt; (\"BLUE\".equalsIgnoreCase(value))) // (2)\n.peek((key, value) -&gt; System.out.println(\"POST-FILTER: key=\" + key + \", value=\" + value))\n.to(outTopicName); // (3)\n</code></pre> <ol> <li><code>Peek()</code> to get the message, apply a lambda function and do nothing else. Used for printing</li> <li><code>filter()</code> to select records. So here there is a transformation of the input kstream and output kstream</li> <li><code>to()</code> is to output the stream to a topic.</li> </ol> <p>Run this test you should see the following output in the Debug Console.   If your IDE is Visual Studio Code, click the \"Run Tests\" icon right of TestYourFirstTopology on the explorer.  . The first part is a print of the defined topology and then the execution of the topology on the different input records.   </p> <pre><code>Topologies:\n   Sub-topology: 0\nSource: KSTREAM-SOURCE-0000000000 (topics: [my-input-topic])\n--&gt; KSTREAM-PEEK-0000000001\n    Processor: KSTREAM-PEEK-0000000001 (stores: [])\n--&gt; KSTREAM-FILTER-0000000002\n      &lt;-- KSTREAM-SOURCE-0000000000\n    Processor: KSTREAM-FILTER-0000000002 (stores: [])\n--&gt; KSTREAM-PEEK-0000000003\n      &lt;-- KSTREAM-PEEK-0000000001\n    Processor: KSTREAM-PEEK-0000000003 (stores: [])\n--&gt; KSTREAM-SINK-0000000004\n      &lt;-- KSTREAM-FILTER-0000000002\n    Sink: KSTREAM-SINK-0000000004 (topic: my-output-topic)\n&lt;-- KSTREAM-PEEK-0000000003\n\n[or.ap.ka.st.pr.in.StreamTask] (main) stream-thread [main] task [0_0] Initialized\n[or.ap.ka.st.pr.in.StreamTask] (main) stream-thread [main] task [0_0] Restored and ready to run\nPRE-FILTER: key=C01, value=blue\nPOST-FILTER: key=C01, value=blue\nPRE-FILTER: key=C02, value=red\nPRE-FILTER: key=C03, value=green\nPRE-FILTER: key=C04, value=Blue\nPOST-FILTER: key=C04, value=Blue\nPRE-FILTER: key=C01, value=blue\nPOST-FILTER: key=C01, value=blue\n[or.ap.ka.st.pr.in.StreamTask] (main) stream-thread [main] task [0_0] Suspended running\n[or.ap.ka.st.pr.in.RecordCollectorImpl] (main) topology-test-driver Closing record collector clean\n[or.ap.ka.st.pr.in.StreamTask] (main) stream-thread [main] task [0_0] Closed clean\n</code></pre> <p>See comments in test class for more information. May be you can play with the data, and change the filter condition. </p>"},{"location":"lab2/#exercise-2-filter-item-transaction-without-a-store","title":"Exercise 2: Filter item transaction without a store","text":"<p>Problem: Given item sold transactions, keep transactions with store and sku information populated.</p> <p>Try to do a topology taking the ItemTransaction class as the code defining the content from the input topic. The following code does not need to be copied/paste. It is here to explain you the structure of the data. The class is in the classpath, so tests run in maven or in the IDE will work.</p> <pre><code>public class ItemTransaction   {\npublic static String RESTOCK = \"RESTOCK\";\npublic static String SALE = \"SALE\";\npublic Long id;\npublic String storeName;\npublic String sku;\npublic int quantity;\npublic String type;\npublic Double price;\npublic String timestamp;\n</code></pre> <p>So the Stream Topology needs to use the <code>filter()</code> function to select items with valid sku and storeName.</p> <p>You should use the TestSecondTopology test class, and implement the Kafka Streams topology in the <code>buildTopologyFlow()</code> method:</p> Build filtering<pre><code>   public static Topology buildTopologyFlow(){\nfinal StreamsBuilder builder = new StreamsBuilder();\n// 1- get the input stream\n// 2 filter\n// Generate to output topic\nreturn builder.build();  }\n</code></pre> <p>In the first exercice, we used String Deserializer. This time we need Java Bean serializer/deserializer. This is a classical task in any Kafka Streams projects to have to define such serdes. The Serialization and Deserialization are defined in the StoreSerdes.class which uses a JSON generic class based on Jackson parser. You should be able to reuse this class in all your project.</p> <p>Do not copy / past the following code. This is just for information so you can see the relationship between Serdes and the Java bean they are supposed to deserialize.</p> JSONSerdes<pre><code>import org.apache.kafka.common.serialization.Deserializer;\nimport org.apache.kafka.common.serialization.Serde;\nimport org.apache.kafka.common.serialization.Serializer;\npublic class JSONSerde&lt;T&gt; implements Serializer&lt;T&gt;, Deserializer&lt;T&gt;, Serde&lt;T&gt; {\nprivate static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\nprivate String className;\npublic JSONSerde(String cn){\nthis.className = cn;\n}\n//..\n</code></pre> <p>An example of specific usage for this class is the StoreSerdes class.</p> <pre><code>public class StoreSerdes {\npublic static Serde&lt;ItemTransaction&gt; ItemTransactionSerde() {\nreturn new JSONSerde&lt;ItemTransaction&gt;(ItemTransaction.class.getCanonicalName());\n}\n// ..\n}\n</code></pre> <p>Using the StoreSerdes, the test topic declarations in the TestCase class, are using the serdes like:</p> setup method<pre><code>// Key of the record is a String, value is a ItemTransaction \ninputTopic = testDriver.createInputTopic(inTopicName, new StringSerializer(), StoreSerdes.ItemTransactionSerde().serializer()); outputTopic = testDriver.createOutputTopic(outTopicName, new StringDeserializer(),  StoreSerdes.ItemTransactionSerde().deserializer());\n</code></pre> <p>Now some guidances of what the Stream topology should look like:</p> <ul> <li>Think to build a Kstream from the input stream</li> <li>The record should have key and value</li> <li>use filter and predicate to test if value.storeName has no value or value.sku is empty or null then drop the message</li> <li>generate output to a topic</li> <li>Think to chain the functions to get accurate result</li> </ul> <p>Use Test Driven Development to build tests before the topology, but here tests are already defined for you.</p> Happy Path Test<pre><code>    @Test\npublic void sendValidRecord(){\nItemTransaction item = new ItemTransaction(\"Store-1\",\"Item-1\",ItemTransaction.RESTOCK,5,33.2);\ninputTopic.pipeInput(item.storeName, item);\nassertThat(outputTopic.getQueueSize(), equalTo(1L) );\nItemTransaction filteredItem = outputTopic.readValue();\nassertThat(filteredItem.storeName, equalTo(\"Store-1\"));\nassertThat(filteredItem.sku, equalTo(\"Item-1\"));\n}\n</code></pre> <ul> <li>Here is a typical trace: the id of the transaction is a timestamp as long, so those values will change.</li> </ul> Expected execution trace<pre><code>Topologies:\nSub-topology: 0\nSource: KSTREAM-SOURCE-0000000000 (topics: [my-input-topic])\n--&gt; KSTREAM-PEEK-0000000001\nProcessor: KSTREAM-PEEK-0000000001 (stores: [])\n--&gt; KSTREAM-FILTER-0000000002\n&lt;-- KSTREAM-SOURCE-0000000000\nProcessor: KSTREAM-FILTER-0000000002 (stores: [])\n--&gt; KSTREAM-PEEK-0000000003\n&lt;-- KSTREAM-PEEK-0000000001\nProcessor: KSTREAM-PEEK-0000000003 (stores: [])\n--&gt; KSTREAM-SINK-0000000004\n&lt;-- KSTREAM-FILTER-0000000002\nSink: KSTREAM-SINK-0000000004 (topic: my-output-topic)\n&lt;-- KSTREAM-PEEK-0000000003\n....\nPRE-FILTER: key=Store-1, value= {id: 1653431482009 Store: Store-1 Item: null Type: RESTOCK Quantity: 5}\nPRE-FILTER: key=Store-1, value= {id: 1653431482107 Store: Store-1 Item: Item-1 Type: RESTOCK Quantity: 5}\nPOST-FILTER: key=Store-1, value= {id: 1653431482107 Store: Store-1 Item: Item-1 Type: RESTOCK Quantity: 5}\nPRE-FILTER: key=, value= {id: 1653431482114 Store:  Item: Item-1 Type: RESTOCK Quantity: 5}\nPRE-FILTER: key=Store-1, value= {id: 1653431482116 Store: Store-1 Item:  Type: RESTOCK Quantity: 5}\nPRE-FILTER: key=null, value= {id: 1653431482118 Store: null Item: Item-1 Type: RESTOCK Quantity: 5}\n</code></pre> Solution <p>The topology looks like <pre><code>KStream&lt;String,ItemTransaction&gt; items = builder.stream(inTopicName, Consumed.with(Serdes.String(),  StoreSerdes.ItemTransactionSerde()));  items.peek((key, value) -&gt; System.out.println(\"PRE-FILTER: key=\" + key + \", value= {\" + value + \"}\"))\n.filter((k,v) -&gt; (v.storeName != null &amp;&amp; ! v.storeName.isEmpty() &amp;&amp; v.sku != null &amp;&amp; ! v.sku.isEmpty())) .peek((key, value) -&gt; System.out.println(\"POST-FILTER: key=\" + key + \", value= {\" + value + \"}\"))\n.to(outTopicName);\n</code></pre></p>"},{"location":"lab2/#exercise-3-dead-letter-topic","title":"Exercise 3: Dead letter topic","text":"<p>Problem: from the previous example, we would like to route the messages with errors to a dead letter topic, for future processing. May be a human intervention? The dead letter topic is a classical integration pattern, and when dealing with Kafka and streaming it looks like:</p> <p></p> <p>Transform the previous topology to support branches and routing the records in error to a dead letter topic. </p> <p>You should use the TestDeadLetterTopic test class, and implement the Kafka Streams topology in the buildTopologyFlow() method:</p> <p>Some guidances:</p> <ul> <li>Define a dead letter topic</li> <li>Create a [StreamsBuilder]: Builder for Kafka Streams topology</li> <li>Create a KStream with key as string and value as ItemTransaction</li> <li>Use the concept of branches by splitting the input stream</li> <li>Use lambda function for testing condition on <code>sku</code> and <code>storeName</code> attributes</li> <li>Output the branches to topics</li> </ul> Solution <ul> <li>Dead letter topic declaration <pre><code>private  static TestOutputTopic&lt;String, ItemTransaction&gt; dlTopic;\nprivate static String deadLetterTopicName = \"dl-topic\";\n</code></pre></li> <li>Define topology <pre><code>final StreamsBuilder builder = new StreamsBuilder();\n// 1- get the input stream\nKStream&lt;String,ItemTransaction&gt; items = builder.stream(inTopicName, Consumed.with(Serdes.String(),  StoreSerdes.ItemTransactionSerde()));  // 2 build branches\nMap&lt;String, KStream&lt;String,ItemTransaction&gt;&gt; branches = items.split(Named.as(\"B-\"))\n.branch((k,v) -&gt; (v.storeName == null ||  v.storeName.isEmpty() || v.sku == null || v.sku.isEmpty()),\nBranched.as(\"wrong-tx\")\n).defaultBranch(Branched.as(\"good-tx\"));\n// Generate to output topic\nbranches.get(\"B-good-tx\").to(outTopicName);\nbranches.get(\"B-wrong-tx\").to(deadLetterTopicName);\n</code></pre></li> <li>Define output topic in setup() <pre><code>dlTopic = testDriver.createOutputTopic(deadLetterTopicName, new StringDeserializer(),  StoreSerdes.ItemTransactionSerde().deserializer());\n</code></pre></li> </ul>"},{"location":"lab2/#exercice-4-using-ktable","title":"Exercice 4 - Using Ktable","text":"<p>Problem: now you want to group record in table and keep last item transaction per store</p> <p>Input examples:</p> <pre><code>{\"id\":9,\"price\":30.0,\"quantity\":10,\"sku\":\"Item_1\",\"storeName\":\"Store_1\",\"timestamp\":\"2022-05-19T16:22:37.287937\",\"type\":\"RESTOCK\"}\n{\"id\":6,\"price\":10.0,\"quantity\":5,\"sku\":\"Item_3\",\"storeName\":\"Store_1\",\"timestamp\":\"2022-05-12T23:13:31.338671\",\"type\":\"SALE\"}\n</code></pre> <p>Expected result in a Ktable - store:</p> <pre><code>Item_3\n</code></pre> <p>Guidances</p> <ul> <li> <p>The input topic is keyed by the SKU so we need to rekey to store name: </p> <pre><code>    inputTopic.pipeInput(item.sku, item);\n</code></pre> </li> <li> <p>Create a Kstream from the items stream</p> </li> <li>use <code>map</code> to generate new KeyValue with key being the storeName</li> <li>Create a Ktable from the output of the map</li> <li>Use materialized view to keep data in a state store (KeyValueStore)</li> </ul> Solution <ul> <li>The topology looks like <pre><code>KStream&lt;String,ItemTransaction&gt; items = builder.stream(inTopicName, Consumed.with(Serdes.String(),  StoreSerdes.ItemTransactionSerde()));  KTable&lt;String,ItemTransaction&gt; lastItemInStore = items\n.map((k,v) -&gt; { return new KeyValue&lt;String,ItemTransaction&gt;(v.storeName, v);\n}).toTable(\nMaterialized.&lt;String, ItemTransaction, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as(storeName)\n.withKeySerde(Serdes.String()).withValueSerde( StoreSerdes.ItemTransactionSerde()));\n</code></pre></li> <li>The trace for the topology: <pre><code>Topologies:\nSub-topology: 0\nSource: KSTREAM-SOURCE-0000000000 (topics: [my-input-topic])\n  --&gt; KSTREAM-MAP-0000000001\nProcessor: KSTREAM-MAP-0000000001 (stores: [])\n  --&gt; KSTREAM-FILTER-0000000004\n  &lt;-- KSTREAM-SOURCE-0000000000\nProcessor: KSTREAM-FILTER-0000000004 (stores: [])\n  --&gt; KSTREAM-SINK-0000000003\n  &lt;-- KSTREAM-MAP-0000000001\nSink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\n  &lt;-- KSTREAM-FILTER-0000000004\n\nSub-topology: 1\nSource: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\n  --&gt; KSTREAM-TOTABLE-0000000002\nProcessor: KSTREAM-TOTABLE-0000000002 (stores: [ItemTable])\n  --&gt; none\n  &lt;-- KSTREAM-SOURCE-0000000005\n</code></pre></li> </ul>"},{"location":"lab2/#more-examples","title":"More examples","text":"<p>For your information here are some more test classes that demonstrate some streaming examples:</p> <ul> <li>TestAccumulateItemSold to demonstrate counting item sold event per sku. It groups by sku, and then count and emit events. Without Ktable caching the sequence of output records is emitted for key that represent changes in the resulting aggregation table.</li> </ul> <pre><code>    KStream&lt;String,ItemTransaction&gt; items = builder.stream(inTopicName, Consumed.with(Serdes.String(),  StoreSerdes.ItemTransactionSerde())); // 2- to compute aggregate we need to group records by key to create KGroupTable or stream\n// here we group the records by their current key into a KGroupedStream \nKTable&lt;String,Long&gt; countedItems = items\n.filter((k,v) -&gt; ItemTransaction.SALE.equals(v.type))\n.groupByKey()\n// 3- change the stream type from KGroupedStream&lt;String, ItemTransaction&gt; to KTable&lt;String, Long&gt;\n.count();\n// Generate to output topic\ncountedItems.toStream().to(outTopicName);\n</code></pre>"},{"location":"lab2/#final-store-inventory-exercice","title":"Final store inventory exercice","text":"<p>As decided during the system design, you need now to implement the proof of concept around streaming restock or sale transaction.</p>"},{"location":"lab2/#problem-statement","title":"Problem statement","text":"<p>How to get the real-time view of the inventory per store?</p> <p>The ItemTransaction.java represents the message structure of the input topic. Below is an extract of this definition:</p> <p>Here is an example of json message you may see in a topic:</p> <pre><code>{\"id\":9,\"price\":30.0,\"quantity\":10,\"sku\":\"Item_1\",\"storeName\":\"Store_5\",\"timestamp\":\"2022-05-19T16:22:37.287937\",\"type\":\"RESTOCK\"}\n{\"id\":6,\"price\":10.0,\"quantity\":5,\"sku\":\"Item_3\",\"storeName\":\"Store_1\",\"timestamp\":\"2022-05-12T23:13:31.338671\",\"type\":\"SALE\"}\n</code></pre> <p>We need to compute aggregate for each store level. For example the outcome may look like:</p> <pre><code>{\"storeName\":\"Store_1\",\"stock\":{\"Item_3\":20,\"Item_2\":0,\"Item_1\":20}}\n</code></pre> <p>Events could be RESTOCK or SALE. The <code>type</code> attribute defines this. <code>sku</code> represents the item identifier.</p> <p>The input topic is <code>items</code> and the output topic is <code>store.inventory</code>. We assume ItemTransaction fields are all present, so the streaming logic does not need to assess data quality.</p>"},{"location":"lab2/#design-questions","title":"Design questions","text":"<ul> <li>What is the data model you need to use to keep store inventory?</li> <li>What event will be produced to the <code>store.inventory</code> topic?</li> <li>We need to process 5 million messages per day. Day is from 6:00 am to 10 pm every day.</li> </ul> Some hints <ul> <li>Define a New class to support keeping Store and a Map for items and current stock value. This class will be the event structure to get to the output topic <li>Use a method to update the quantity of an existing inventory instance with a new retrieved event</li> <li>Use KStream aggregate function to create new entry and update existing store entry</li> <p>Solution review and code explanation&gt;&gt;</p>"},{"location":"lab2/kstream/","title":"Kafka Streams Study","text":"<p>You need to understand some basic on how to use the Kafka Stream APIs so you can develop some simple streaming applications in a scope of a proof of concept.</p>"},{"location":"lab2/kstream/#kafka-stream-concepts","title":"Kafka Stream concepts","text":"<p>Any Java or Scala application can use Kafka Streams APIs.</p>"},{"location":"lab2/kstream/#topology","title":"Topology","text":"<p>The business logic is implemented via a Kafka Streams \"topology\" which represents a graph of processing operators or nodes. Each node within the graph, processes events from the parent node and may generate events for the down stream node(s).  This is really close to the Java Streaming APIs or Mutiny APIs, but the APIs used by the topology is from Kafka Streams APIS.</p> <p>Kafka Streams applications are built on top of Kafka producer and consumer APIs and are leveraging Kafka capabilities to do data parallelism processing, to support distributed coordination of partition to task assignment, and to support fault tolerance. In Java the streaming topology will be executed in multiple threads and explicitly started in the Java app.</p> <pre><code>  Properties props = buildKafkaProperties();\nkafkaStreams = new KafkaStreams(buildProcessFlow(), props);\nkafkaStreams.start();\n</code></pre> <p>To build a topology we use a StreamsBuilder class to define the input streams (mapped to a Kakfa topic), the logic to apply to the events and then how to produce results to a Kafka topic.</p> Define a topology<pre><code>// Create a builder\nfinal StreamsBuilder builder = new StreamsBuilder(); // (1)\n// define the KStream abstraction by defining where the data come from (topic) and in which format\nKStream&lt;String,ItemTransaction&gt; items = builder.stream(itemSoldInputStreamName, Consumed.with(Serdes.String(),  StoreSerdes.ItemTransactionSerde()));  // (2)\nfinal Topology topology = builder.build();\n// start the topology in a thread... we will this code later\n</code></pre> <ol> <li>StreamsBuilder to build a topology and run it</li> <li>Define a stream from a topic with serialization of the value to a Java Bean</li> </ol> <p>The following figure illustrates the topology concept:</p> <p></p> <p>So let start by learning more about KStream construct.</p> More Reading <ul> <li>If you do not know about topic, kafka producer, and consumer, you may spend time to read some quick kafka concepts</li> <li>More about producer practice</li> <li>And consumer</li> <li>More advanced practices for producer and consumer</li> </ul>"},{"location":"lab2/kstream/#kstream-api","title":"KStream API","text":"<p>KStream is an abstraction of a Kafka record stream. It can be defined from one ot multiple Topics, and will define the structure of the Kafka record key, and the record structure.</p> <p>The following declaration is for consuming from topic named <code>items</code> with Key and Value of type <code>String</code>:</p> <pre><code> KStream&lt;String, String&gt; aStream = builder.stream(\"items\",Consumed.with(Serdes.String(), Serdes.String()));\n</code></pre> <p>Then Kstream offers a lot of functions to process the records. Below is a quick summary of the methods you may need to use in the next exercises:</p> Method What it does Example peek Perform an action on each record of KStream. aStream.peek((key, value) -&gt; System.out.println(value) to transform the stream to a topic aStream.to(outTopicName) filter Create a new KStream with records which satisfy the given predicate. .filter((key, value) -&gt; (\"BLUE\".equalsIgnoreCase(value))) split Split this stream into different branches. aStream.split().branch((key, value) -&gt; value.userId == null, Branched.as(\"no-userid\")).defaultBranch(Branched.as(\"non-null\")); groupBy Group the records of this KStream on current key groupByKey Group the records of this KStream on a new key KGroupedStream Intermediate representation of a KStream in order to apply an aggregation operation Ouput of groupByKey aggregate Aggregate the values of records in this stream by the grouped key .aggregate(() -&gt;  new StoreInventory(), (store , newItem, existingStoreInventory) -&gt; existingStoreInventory.updateStockQuantity(store,newItem), materializeAsStoreInventoryKafkaStore()); split Split a stream into branches items.split(Named.as(\"B-\")) BranchedKStream Branches the records in the original stream based on the predicates supplied for the branch definitions. .branch((k,v) -&gt; (v.storeName == null), Branched.as(\"wrong-tx\")).defaultBranch(Branched.as(\"good-tx\"));   branches.get(\"B-good-tx\").to(outTopicName); branches.get(\"B-wrong-tx\").to(deadLetterTopicName); selectKey Change the key of a record"},{"location":"lab2/kstream/#ktable","title":"KTable","text":"<p>KTable is the second main abstraction of a changelog stream from a primary-keyed table. Each record in this changelog stream is an update on the primary-keyed table with the record key as the primary key.</p> <p>A stream can be considered a changelog of a table, where each data record in the stream captures a state change of the table.</p> <p>The figure below is a simplication of both concepts:</p> <p></p> <p>A Kstream is first connect to a topic and will receive events with Key,Value structure, as unbounded stream. You can chain Kstream to build a topology, and to a Ktable, which will keep only the last value of a given key. To ouput to a Kafka topic, the final construct is a KStream.</p> <p>KStreams are in memory, Ktables are also in memory but may be persisted. KTable assumes that records from the source topic that have null keys are simply dropped.</p> <p>KTable can be created directly from a Kafka topic (using StreamsBuilder.table operator), as a result of transformations on an existing KTable, or aggregations (aggregate, count, and reduce). </p> <p>Stateful transformations depend on state for processing inputs and producing outputs and require a state store associated with the stream processor. For example, in aggregating operations, a windowing state store is used to collect the latest aggregation results per window.</p> <p>KTables need to additionally maintain their respective state in between events so that operations like aggregations (e.g.,\u00a0COUNT()) can work properly.\u00a0</p> <p>Every ktable has its own state store. Any operation on the table such as querying, inserting, or updating a row is carried out behind the scenes by a corresponding operation on the table\u2019s state store.</p> <p>These state stores are being\u00a0materialized on local disk\u00a0inside your application instances. </p> <p>Kafka Streams uses RocksDB as the default storage engine for persistent state stores. RockDB is a fast key-value server, especially suited for storing data on flash drives.</p> <p>The following figure summarizes all those concepts:</p> <p></p> <p>There are as many caches as there are threads, but no sharing of caches across threads happens. Records are evicted using a simple LRU scheme after the cache size is reached.  The semantics of caching is that data is flushed to the state store and forwarded to the next downstream processor node whenever the earliest of <code>commit.interval.ms</code> or <code>cache.max.bytes.buffering</code> (cache pressure) hits. As illustrated in the example TestAccumulateItemSoldWithCaching when using cache, records are output at the end of the commit interval or when reaching max buffer size.</p> <p>Interesting methods:</p> Method What it does Example filter Create a new KTable that consists of all records of this KTable which satisfy the given predicate join join streams with tables or table to table Read more <ul> <li>Apache Kafka - TUTORIAL: WRITE A KAFKA STREAMS APPLICATION</li> <li>KStream API</li> <li>Ktable API</li> <li>Kafka Streams summary</li> <li>Other labs</li> </ul>"},{"location":"lab2/lab2-sol/","title":"Lab 2 solution","text":""},{"location":"lab2/lab2-sol/#the-output-inventory-class","title":"The output inventory class","text":"<p>The class needs to keep store name and a map of items and current inventory. The class is StoreInventory</p> <pre><code>public class StoreInventory  {\npublic String storeName;\n// map &lt;item_id,quantity&gt;\npublic HashMap&lt;String,Long&gt; stock = new HashMap&lt;String,Long&gt;();\n</code></pre> <p>This class is used to get to the out topic but inside the Store and aggregate via the update method:</p> <pre><code>public StoreInventory updateStockQuantity(String key, ItemTransaction newValue) {\nthis.storeName = key;\nif (newValue.type != null &amp;&amp; ItemTransaction.SALE.equals(newValue.type))\nnewValue.quantity=-newValue.quantity;\nreturn this.updateStock(newValue.sku,newValue.quantity);\n}\npublic StoreInventory updateStock(String sku, long newV) {\nif (stock.get(sku) == null) {\nstock.put(sku, Long.valueOf(newV));\n} else {\nLong currentValue = stock.get(sku);\nstock.put(sku, Long.valueOf(newV) + currentValue );\n}\nreturn this;\n}\n</code></pre>"},{"location":"lab2/lab2-sol/#developing-the-topology-in-test-class","title":"Developing the Topology in test class","text":"<p>Continuing test with the TopolofyTestDriver, you will implement the topology with the same structure as before. Here what the topology needs to do:</p> <ul> <li>Get ItemTransaction from input stream the Key being the storeName</li> <li>Aggregation wwork on keyed group, so groupByKey the input records</li> <li>Aggregate using the update method.</li> </ul> <p>The stream topology looks like:</p> <pre><code>    KStream&lt;String,ItemTransaction&gt; items = builder.stream(inTopicName, Consumed.with(Serdes.String(),  StoreSerdes.ItemTransactionSerde()));  // 2 processing   \n// process items and aggregate at the store level \nKTable&lt;String,StoreInventory&gt; storeItemInventory = items\n// use store name as key, which is what the item event is also using\n.groupByKey()\n// update the current stock for this &lt;store,item&gt; pair\n// change the value type\n.aggregate(\n() -&gt;  new StoreInventory(), // initializer when there was no store in the table\n(store , newItem, existingStoreInventory) -&gt; existingStoreInventory.updateStockQuantity(store,newItem), Materialized.&lt;String, StoreInventory, KeyValueStore&lt;Bytes, byte[]&gt;&gt;as(STORE_INVENTORY_KAFKA_STORE_NAME)\n.withKeySerde(Serdes.String())\n.withValueSerde( StoreSerdes.StoreInventorySerde())\n);   // Generate to output topic\nstoreItemInventory.toStream().to(outTopicName,\nProduced.with(Serdes.String(), StoreSerdes.StoreInventorySerde()));\n</code></pre>"},{"location":"lab2/lab2-sol/#the-full-application-code-analysis","title":"The full application code analysis","text":"<p>In fact the topology creation is defined in a business service. The microservice application is using the Liberty runtime and API and the code organization uses the <code>onion</code> architecture introduced in the Domain-driven design:</p> <pre><code>* `domain` contains the business logic and business entities related to item transaction and store inventory.\n* `infra` is for infrastructure code, containing JAXRS class, event processing, and ser-des.\n</code></pre> <pre><code>                \u251c\u2500\u2500 app\n                \u2502\u00a0\u00a0 \u2514\u2500\u2500 StoreAggregatorApplication.java\n                \u251c\u2500\u2500 domain\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 ItemTransaction.java\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 StoreInventory.java\n                \u2502\u00a0\u00a0 \u2514\u2500\u2500 StoreInventoryAggregator.java\n                \u2514\u2500\u2500 infra\n                    \u251c\u2500\u2500 api\n                    \u2502\u00a0\u00a0 \u251c\u2500\u2500 StoreInventoryQueries.java\n                    \u2502\u00a0\u00a0 \u251c\u2500\u2500 StoreInventoryResource.java\n                    \u2502\u00a0\u00a0 \u251c\u2500\u2500 VersionResource.java\n                    \u2502\u00a0\u00a0 \u2514\u2500\u2500 dto\n                    \u2502\u00a0\u00a0     \u251c\u2500\u2500 InventoryQueryResult.java\n                    \u2502\u00a0\u00a0     \u251c\u2500\u2500 ItemCountQueryResult.java\n                    \u2502\u00a0\u00a0     \u2514\u2500\u2500 PipelineMetadata.java\n                    \u2514\u2500\u2500 events\n                        \u251c\u2500\u2500 ItemProcessingAgent.java\n                        \u251c\u2500\u2500 JSONSerde.java\n                        \u251c\u2500\u2500 KafkaConfig.java\n                        \u251c\u2500\u2500 KafkaPropertiesUtil.java\n                        \u2514\u2500\u2500 StoreSerdes.java\n</code></pre> <p>The topology is in the Domain layer in the StoreInventoryAggregator classhttps://github.com/ibm-cloud-architecture/eda-tech-academy/blob/main/lab2/refarch-eda-store-inventory/src/main/java/ibm/gse/eda/stores/domain/StoreInventoryAggregator.java.</p> <p>The Topology is started in a thread in the ItemProcessingAgent class when the application starts, by looking at the <code>StartupEvent</code></p> <pre><code>    void onStart(@Observes StartupEvent ev){\nthis.kafkaStreams = initializeKafkaStreams();\nlogger.info(\"ItemProcessingAgent started\");\n}\n</code></pre>"},{"location":"lab3/","title":"Lab 3: Item inventory demonstration deployment","text":"<p>Duration: 20 minutes</p>"},{"location":"lab3/#goals","title":"Goals","text":"<p>In this lab, you will learn how to deploy the real-time solution by simply using this repository and a minimum set of commands. The approach is to present reusable structure you may want to use for your own future proof of concept development, so it will be easy to demonstrate your solution.</p> <p>The following diagram illustrates the components, you will deploy in your student's namespace using this repository.</p> <p></p>"},{"location":"lab3/#more-context","title":"More context","text":"<p>A traditional solution may be organized with one git repository per application, and at least one GitOps repository to define the deployment artifacts. If you look at the demonstration you are running in this lab, the source code is in the public git account ibm-cloud-architecture with other repositories with following structure:</p> <p></p> <ul> <li>eda-rt-inventory-gitops: the solution gitops repo, built with kam cli which includes everything to declare ArgoCD apps and deployment descriptors</li> <li>eda-gitops-catalog: a git repository to define the different Cloud Pak for Integration operator versions.</li> <li>store simulator application the simulator to send messages to different middleware</li> <li>store aggregator / inventory application to compute store inventory aggregates with Kafka Streams</li> <li>item aggregator / inventory application same for item inventory cross store.</li> </ul>"},{"location":"lab3/#pre-requisites","title":"pre-requisites","text":"<p>See Pre-requisites section in the main page.  MAC users can run all the commands in this lab from terminal window.  Windows users will have to run the commands from a WSL Command window. Open a CMD window and type 'bash' to enter the WSL prompt.   </p>"},{"location":"lab3/#preparation","title":"Preparation","text":"<p>Each Student will have received a unique identifier and will modify the current settings in this folder with their student id.  All the current kubernetes configurations are currently set for <code>poe1</code>.</p> <p>We assume the following are pre-set in you OpenShift cluster, which is the same as CoC integration cluster:</p> <ul> <li>Platform navigator is deployed in <code>cp4i</code> project.</li> <li> <p>Event Streams is installed under <code>cp4i-eventstreams</code> project.</p> </li> <li> <p>Login to the OpenShift cluster assigned to you (poe or ashoka) using the login command from the OpenShift Console</p> <p></p> <p>Then copy this line:</p> <p></p> <p>Accept the insecure connection</p> <pre><code>oc login --token=sha256~q......pw --server=https://api.cody.coc-ibm.com:6443\nThe server uses a certificate signed by an unknown authority.\nYou can bypass the certificate check, but any data you send to the server could be intercepted by others.\nUse insecure connections? (y/n): y\n</code></pre> </li> <li> <p>Verify your <code>oc</code> cli works</p> <pre><code>oc get nodes\n</code></pre> </li> <li> <p>Work under the <code>lab3-4</code> folder of this repository.</p> </li> </ul>"},{"location":"lab3/#modify-existing-configuration","title":"Modify existing configuration","text":"<p>We will prepare the configuration for the following green components in figure below:</p> <p></p> <p>The blue components should have been deployed with the Cloud Pak for Integration deployment. </p> <ol> <li> <p>The demonstration will run on its own namespace. The <code>env/base</code> folder includes the definition of the namespace, roles, role binding needed to deploy the demonstration. This is a classical way to isolate apps in kubernetes. </p> <p>Running the <code>updateStudent.sh</code> shell script, will modify all the yaml files used by the solution with your student id. As an example we will be student <code>poe10</code> and the deployment will be done in <code>poe10</code> namespace. </p> <ul> <li> <p>Mac User:</p> <pre><code>export PREFIX=poe10\n./updateStudent.sh\n</code></pre> </li> <li> <p>Windows user (in Linux shell)</p> <pre><code>export PREFIX=poe10\nsudo dos2unix updateStudent.sh  sudo dos2unix argocd/updateStudent.sh\n./updateStudent.sh\n[ The argocd/updateStudent.sh will be executed in the next lab]\n</code></pre> </li> </ul> </li> </ol>"},{"location":"lab3/#folder-structure","title":"Folder structure","text":"<p>This <code>lab3-4</code>folder is a reduced version of what the Red Hat's Kubernetes Application Management tool is creating normally. If you want to see a full fledge GitOps version for this demonstration see the eda-rt-inventory-gitops repository.</p> Folder Intent apps Defines deployment, config map, service and route for the 3 applications and kafka connector env Defines the namespace for each deployment, and some service account services Defines MQ broker instance, Kafka Connect cluster, and event streams topics argocd Define the ArgoCD project and apps to monitor this git repo. It will be used for lab 4"},{"location":"lab3/#deploy","title":"Deploy","text":"<p>The deployment will configure topics in event streams using a naming convention to avoid conflicts between students, deploy the three apps, deploy MQ broker and Kafka Connect cluster with the MQ source connector configured.</p> <p></p> <p>Event Gateway, schema registry, and Cloud Object Storage sink connector are not used in this lab</p> <ol> <li> <p>Start the deployment</p> <pre><code>make all-no-gitops\n</code></pre> </li> <li> <p>Verify the solution is up and running</p> <p><pre><code>oc project $PREFIX\noc get pods\noc get routes oc get kafkatopic -n cp4i-eventstreams\noc get kafkauser -n  cp4i-eventstreams\n</code></pre> </p> </li> <li> <p>Access to the MQ console (replace the namespace and base url)</p> <pre><code># Open this link in a browser. change poe to another server name if needed\nhttps://cpd-cp4i.apps.poe.coc-ibm.com/integration/messaging/$PREFIX/$PREFIX-mq-ibm-mq/\n</code></pre> </li> <li> <p>Verify the queue manager has the ITEMS queue </p> <p></p> </li> <li> <p>Access to the simulator console</p> <pre><code>Get the URL of the Store Simulator and open it in a browser. oc get route store-simulator -o jsonpath='{.status.ingress[].host}'\n</code></pre> <p>Go to the SIMULATOR tab. If you want to test with the MQ source connector, select IBMMQ backend, and starts the <code>Controlled scenario</code> to send predefined messages: </p> <p></p> <p>Normally you should not see the messages in the ITEMS queue as they are immediatly processed by the Kafka Connector. </p> <p>You should get a set of predefined messages sent to MQ, and then to Kafka <code>$PREFIX-items</code> topic</p> <p></p> <p>Go to the Event Streams console.</p> <p>If you select <code>Kafka</code> as backend, then the simulator sends directly the messages to Kafka <code>$PREFIX-items</code> topic.</p> </li> <li> <p>The two other options for the Store simulator is to send from 1 to 100 random messages (left choice in the controller view), or continuously send messages (start / stop control in the middle of the page).</p> </li> <li> <p>Access the Event Stream console to look at topic content:</p> </li> </ol> <pre><code># Open this link in a browser. change poe to the OCP cluster name. Login with you user-id using the Enterprise LDAP.\nhttps://cpd-cp4i.apps.poe.coc-ibm.com/integration/kafka-clusters/cp4i-eventstreams/es-demo/\n</code></pre> <p>The <code>items</code> topic content the store transactions:</p> <p></p> <p>The <code>item.inventory</code> topic has the aggregates cross stores, as illustrates in figure below:</p> <p></p> <p>And the <code>store.inventory</code> includes events on current inventory per store:</p> <p></p>"},{"location":"lab3/#test-the-full-setup","title":"Test the Full Setup","text":"<ol> <li>From the EventStreams portal, go to Topics and open the items-inventory topic (USERID-item.inventory)</li> <li>Go to Messages. </li> <li>Open the first few messages and take note of the ItemID and CurrentStock. E.g. </li> <li>From the Store Simulator page -&gt; Click on Simulator.</li> <li>Choose IBM MQ for BackEnd. </li> <li>Send one random message. Take note of the message sent. In particular, take note of Item number, Type (either SALE or RESTOCK) and quantity. </li> <li>Go to the EventStreams portal and check if the new message has arrived in USERID-items topic.  </li> <li>From the EventStreams portal one new message should also be delivered to the USERID-item.inventory topic. Check the message.  The quantity should have been increased (Type RESTOCK) or reduced (SALE) by the quantity number (sent via Store Simulator). </li> <li>You can also do a similar check in USERID-store.inventory topic.</li> </ol> Read more on the demonstration script <p>The demonstration instructions are in a separate note as this is a demonstration available in the public git and shareable with anyone.</p>"},{"location":"lab3/#kafka-connector-configuration","title":"Kafka connector configuration","text":"<p>The Kafka connect cluster is defined in the kafka-connect.yam file in the <code>services/kconnect</code> folder. The important part of this file is the Event Streams bootstrap server URL, the kafka version used, and the name of the topic used to persist states of the connector. Each student has its own topic names for offsets, config and status topics.</p> <pre><code>  version: 3.0.0\nreplicas: 2\nbootstrapServers: es-demo-kafka-bootstrap.cp4i-eventstreams.svc:9093\nimage: quay.io/ibmcase/eda-kconnect-cluster-image:latest\n# ... \nconfig:\ngroup.id: poe10-connect-cluster\noffset.storage.topic: poe10-connect-cluster-offsets\nconfig.storage.topic: poe10-connect-cluster-configs\nstatus.storage.topic: poe10-connect-cluster-status\nconfig.storage.replication.factor: 3\noffset.storage.replication.factor: 3\nstatus.storage.replication.factor: 3\n</code></pre> <p>Recall that the kafka connect cluster runs connectors in parallel and use Kafka consumer and producer API to do the data transfer.</p> <p></p> <p>The <code>image</code> references a custom image we built to have the MQ source connector and some sink. The Dockerfile for this image is in this repository, you can start from it to add more connector.</p> <p>To set the status of the kafka connect cluster runs the following command:</p> <pre><code>oc get kafkaconnect\n# example of results\nNAME                    DESIRED REPLICAS   READY\npoe10-connect-cluster   2                  True\n</code></pre> <ul> <li>The MQ source connector is defined as an app, in the <code>apps/mq-source</code> folder. Below are the important parts to consider:</li> </ul> <pre><code>  config:\nmq.queue.manager: poe10MQ\nmq.connection.name.list: poe10-mq-ibm-mq.poe10.svc\nmq.channel.name: DEV.APP.SVRCONN\nmq.queue: ITEMS\ntopic: poe10-items\nkey.converter: org.apache.kafka.connect.storage.StringConverter\nvalue.converter: org.apache.kafka.connect.storage.StringConverter\nmq.record.builder: com.ibm.eventstreams.connect.mqsource.builders.DefaultRecordBuilder\nmq.connection.mode: client\nmq.message.body.jms: true\nmq.record.builder.key.header: JMSCorrelationID\n</code></pre> <p>We do not need to apply any logic on the value conversion. As the messages in MQ are json, we can just consider them as String. The <code>mq.record.builder.key.header: JMSCorrelationID</code> is very important to get the key from the MQ message header. This is a trick here to avoid having a kafks streams program to extract the key from the message and write to another topic, as it could be in real life. The store simulator uses the JMSCorrelationID to post the \"StoreName\" value as a a future key. The Kafka connector use this to write a kafka Producer Record with this key. </p> <pre><code> public void sendMessage(Item item) {\ntry {\nString msg = parser.toJson(item);\nTextMessage message = jmsContext.createTextMessage(msg);\nmessage.setJMSCorrelationID(item.storeName);\nproducer.send(destination, message);\n...\n</code></pre> <p>If you want to see the status of the connectors</p> <pre><code>oc get kafkaconnectors\n# example of results\nNAME        CLUSTER                 CONNECTOR CLASS                                           MAX TASKS   READY\nmq-source   poe10-connect-cluster   com.ibm.eventstreams.connect.mqsource.MQSourceConnector   1           True\n</code></pre> Read more on Kafka connector <ul> <li>Techno overview</li> <li>Event Streams Product documentation</li> <li>Strimzi configuration</li> <li>Kafka documentation</li> <li>Kafka connector sink to cloud object storage</li> <li>Kafka connector sink to aws S3 with Camel connector</li> </ul>"},{"location":"lab3/#cleaning-your-openshift-project","title":"Cleaning your OpenShift project","text":"<p>Run the following command to clean the demonstration deployment. You MUST clean the deployment if you will do next GitOps lab.</p> <pre><code>oc project $PREFIX\nmake clean\n</code></pre> <p>Upon cleaning, check if there are any pods or topics.   </p>"},{"location":"lab3/#troubleshooting","title":"Troubleshooting","text":""},{"location":"lab3/#message-not-sent-to-mq","title":"Message not sent to MQ","text":"<p>This could come from a connection issue between the simulator and MQ. Get the logs for the simulator pod:</p> <pre><code>oc get pod -l app.kubernetes.io/name=store-simulator\noc logs &lt;pod_id&gt;\n</code></pre>"},{"location":"lab3/#some-topics-not-created","title":"Some topics Not created.","text":"<ol> <li>If the USERID-items topic is not created, try submitting some messages from the Store Simulator.</li> <li>If topics like USERID-item.invetory or USERID-store.inventory is not created, try restarting the following pods: store-simulator-*. item-inventory-*. Then, try sending some messages through the Store Simulator.   </li> </ol>"},{"location":"lab3/#running-locally","title":"Running locally","text":"<p>Do this step ONLY if you do not have an openshift environment. You will require Docker to complete this step. During proof of concept development you can run Event Streams, MQ and your code on your own laptop with docker engine. We give you a docker compose file to do so. Here are the commands to run the same demonstration locally:</p> <pre><code>cd local\ndocker-compose up -d\n./listTopics.sh\n</code></pre> <ul> <li>Access simulator user interface at http://localhost:8080.</li> <li>Access MQ UI at https://localhost:9443.</li> <li>Access Kafdrop UI http://localhost:9000 to look at the topic content.</li> </ul>"},{"location":"lab4/","title":"GitOps deployment with Day 2 operations","text":"<p>In this exercise, you will use GitOps to deploy ArgoCD apps that monitor your git repository for any configuration changes you are doing via Pull Request or Git Commit operations and then apply those changes to the deployed applications.</p> <p>The figure below illustrates the components involved:</p> <p></p> <p>In this lab the operators are already installed in the OpenShift cluster under the <code>openshift-operators</code> project, and products are already install too. So this lab is aimed to deploy the components of the real-time inventory demo (the green components in figure above).</p> <p>As stated before you need to fork this repository under your own public git account, as all configurations will be monitored from your own git repository.</p>"},{"location":"lab4/#pre-requisites","title":"Pre-Requisites","text":"<p>See Pre-requisites section in the main page.  MAC users can run all the commands in this lab from terminal window.  Windows users will have to run the commands from a WSL Command window. Open a CMD window and type 'bash' to enter the WSL prompt.   </p> <p>You should have completed / attempted Lab 3. Specifically, you should have run the \"updateStudent.sh\" script which makes namespace changes in the yaml files. </p>"},{"location":"lab4/#deployment","title":"Deployment","text":"<ol> <li> <p>Verify the OpenShift GitOps Operator is installed on your OpenShift cluster. In fact it should be installed, but this command may be helpful to you in your future proof of concepts.</p> <p>Work in the <code>eda-tech-academy/lab3-4</code> folder.</p> <pre><code>make verify-argocd-available\n</code></pre> <p>Should get this output if not installed</p> <pre><code>Installing\nComplete\n</code></pre> <p>Or this output if it is already installed.</p> <pre><code>openshift-gitops-operator Installed\n</code></pre> </li> <li> <p>Prepare the ArgoCD app and project: Each student will have his/her own project within ArgoCD.</p> <ul> <li>Automatic way:</li> </ul> <pre><code># under the lab3-4 folder\nexport PREFIX=poe10\nexport GIT_ACCOUNT=&lt;yourname GIT account name&gt;\n# same exported variables as before\nsudo make prepare-argocd\n</code></pre> <ul> <li>Manual way:.  [Update the namespace, project, and repoURL elements in the <code>argocd/*.yaml</code> files.]</li> </ul> </li> <li> <p>To get the ArgoCD <code>admin</code> user's password use the command</p> <pre><code>oc extract secret/openshift-gitops-cluster -n openshift-gitops --to=-\n</code></pre> </li> <li> <p>Get the ArgoCD User Interface URL and open it in a web browser</p> <pre><code>oc get route openshift-gitops-server -o jsonpath='{.status.ingress[].host}'  -n openshift-gitops\n</code></pre> </li> <li> <p>Verify you are able to login to the ArgoCD portal.</p> <p></p> </li> <li> <p>Go to applications and ensure there are no applications that have been created. </p> </li> <li> <p>Commit and push your changes to your gitops repository (The fork for eda-tech-academy).      You can use GitHub desktop or git CLI to push the changes to your repository. Here we are using the git CLI.</p> <ul> <li>You can add a remote URl by replacing with your GitHub username in git.</li> </ul> <pre><code>git remote add mine https://github.com/&lt;yourusername&gt;/eda-tech-academy.git\n</code></pre> <pre><code>git commit -am \"update configuration for my student id\"\ngit push -u mine  Enter your github id and Token. </code></pre> <p>Please note Github requires Personal Access Token for Github Operations. You can refer here for more details.  https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token</p> </li> <li> <p>Bootstrap Argocd:  </p> <pre><code>make gitops\n</code></pre> </li> <li> <p>Verify in the ArgoCD console the apps are started and process the synchronization.</p> <p></p> </li> </ol>"},{"location":"lab4/#demonstration","title":"Demonstration","text":"<p>You should be in the same state as in Lab 3 with the Simulator, the two kafka streams app, MQ and Kafka Connect</p> <pre><code>oc get pods\noc get kafkaconnectors\noc -n cp4i-eventstreams get kafkatopics\n</code></pre> <p>Lets do one simple test to see the imapct of ArgoCD.  Edit this file: lab3-4/apps/item-inventory/base/deployment.yaml. and change spec.replicas to 2. Push you change to Github using GitHub Desktop or git CLI. Wait for a few minutes and check the pods.  </p> <p>oc get pods.</p> <p>You should see the replicas for item-inventory has increased. There should be 2 pods now.  You can check ArgoCD view and see 2 pods. </p>"},{"location":"lab4/#clean-up","title":"Clean up","text":"<ol> <li> <p>Full clean up the deployment</p> <p>If you want to stop working and clean the OpenShift cluster and event streams elements</p> <p>```sh make clean-gitops</p> </li> </ol>"},{"location":"lab5/","title":"Intro to Instana Observability for Event Streams (Kafka) Messaging","text":"<p>This is a brief introduction to how you can observe your Event Streams Deployment along with applications in a simulated \"Day 2\" operations mode.</p> <p>In this exercise, you will see how Instana can monitor: OCP, Kafka Brokers, Zookeeper, Kafka Connect and custom deployed applications.</p>"},{"location":"lab5/#demonstration-by-instana-tech-sellers","title":"Demonstration by Instana Tech Sellers","text":"<p>The Instana Tech Sellers will show a demo of Instana.</p>"},{"location":"lab5/#access-the-instana-instance-connected-to-the-event-streams-cluster","title":"Access the Instana Instance connected to the Event Streams Cluster","text":"<ol> <li> <p>Go directly to Instana Home Page </p> </li> <li> <p>Login using user id: trainerintegration@gmail.com and the password given to you by the instructors.  Note: all attendees will use the same login credentials. After you login you should see something like the following.</p> <p></p> </li> <li> <p>Optional - If this is the first time to the site you might have to dismiss the message in the top right corner by single clicking on it.</p> <p></p> </li> <li> <p>Explore the left navigation bar by hovering your mouse over the black bar on the left side.  You should see something like the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#base-infrastructure-observability","title":"Base Infrastructure Observability","text":""},{"location":"lab5/#ocp-worker-nodes-cluster-map","title":"OCP Worker Nodes - Cluster Map","text":"<ol> <li> <p>Go directly to Infrastructure for OCP Worker Nodes you should see something like the following.</p> <p></p> </li> <li> <p>Click the down arrow next to \"Hosts (6)\" in the white box in the upper left corner to see all 6 worker nodes.</p> <p></p> </li> <li> <p>Click one of the worker nodes and you should see something like the following.  Note: you can scroll and open accordians.</p> <p></p> </li> <li> <p>Click \"Open Dashboard\" button and you should see something like the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#ocp-worker-nodes-cluster-k8s-dashboard","title":"OCP Worker Nodes - Cluster k8s Dashboard","text":"<ol> <li> <p>Go directly to Infrastructure for OCP Worker Nodes you should see something like the following.  Note the master and worker nodes are shown along with all the namespaces and the deployments.</p> <p></p> </li> </ol>"},{"location":"lab5/#all-kubernetes-services-for-the-event-streams-cluster","title":"All Kubernetes Services for the Event Streams Cluster","text":"<ol> <li> <p>Go directly to Kubernetes Cluster Services for cp4i-eventstreams OCP cluster you should see something like the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#kafka-brokers","title":"Kafka Brokers","text":"<ol> <li> <p>Go directly to Kubernetes Cluster Services for es-demo-kafka-brokers Kafka Brokers you should see something like the following.</p> <p></p> <p>And Scroll down to see the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#zookeeper-services","title":"Zookeeper Services","text":"<ol> <li> <p>Go directly to Kubernetes Cluster Services for Zookeeper you should see something like the following.</p> <p></p> <p>And Scroll down to see the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#application-and-message-dependencies","title":"Application and Message Dependencies","text":"<ol> <li> <p>Go directly to Application Dependencies for the Messages you should see something like the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#application-message-flow-and-end-to-end-observability","title":"Application Message Flow and End to End Observability","text":"<p>Instana is the ONLY tool that provides full end to end Kafka Message Observability.</p>"},{"location":"lab5/#all-services-with-dependencies-unfiltered","title":"All Services with Dependencies - Unfiltered","text":"<ol> <li> <p>Go directly to Map of All Services with Dependencies - Unfiltered you should see something like the following.</p> <p></p> </li> </ol>"},{"location":"lab5/#message-based-dependencies-filtered","title":"Message-based Dependencies - Filtered","text":"<ol> <li> <p>Go directly to Map of Message-based Dependencies - Filtered you should see something like the following.</p> <p></p> </li> <li> <p>The instructors can demonstrate more capabilities for end to end messages.</p> </li> </ol>"},{"location":"lab5/#failure-root-cause-analyis","title":"Failure &amp; Root Cause Analyis","text":""},{"location":"lab5/#simulate-failure","title":"Simulate Failure","text":"<ol> <li>This will be a future exercise and/or demo.</li> </ol>"},{"location":"lab5/#drill-down-to-root-cause","title":"Drill down to Root Cause","text":"<ol> <li>This will be a future exercise and/or demo.</li> </ol>"},{"location":"lab5/#optionaltakeaway-explore-instana-functionality-using-the-instana-cloud-sandbox","title":"Optional/Takeaway - Explore Instana functionality using the Instana Cloud Sandbox","text":"<ol> <li> <p>Go directly to Instana Cloud Sandbox Instance and login using your IBM email address.</p> </li> <li> <p>After you login using your IBM email addess you should see something like the following.</p> <p></p> </li> <li> <p>Click on the \"Get Started\" button at the bottom left hand corner.  Follow each of the 5 tutorials to get a feel for Instana.</p> <p></p> </li> </ol>"}]}